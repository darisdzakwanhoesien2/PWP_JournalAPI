# app.py
# PWP_JournalAPI/app.py
import os
from flask import Flask
from flask_jwt_extended import JWTManager
from flasgger import Swagger

from extensions import db
from journalapi.api import api_bp
from journalapi.cli import init_db_command
from journalapi.utils import json_response  # ‚úÖ Custom response utility

def create_app(test_config=None):
    app = Flask(__name__, instance_relative_config=True)

    app.config.from_mapping(
        DEBUG=True,
        SECRET_KEY="dev",
        SQLALCHEMY_DATABASE_URI="sqlite:///" + os.path.join(app.instance_path, "journal.db"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
        SWAGGER={"title": "PWP Journal API", "uiversion": 3}
    )

    if test_config:
        app.config.update(test_config)

    # Ensure instance folder exists
    os.makedirs(app.instance_path, exist_ok=True)

    # Initialize extensions
    db.init_app(app)
    JWTManager(app)

    # ‚úÖ Load OpenAPI spec from file
    Swagger(app, template_file="docs/openapi.yaml")

    # ‚úÖ Add a root health-check route
    @app.route("/")
    def root():
        return json_response({"message": "‚úÖ Journal API is running!"}, 200)

    # Register blueprint and CLI command
    app.register_blueprint(api_bp)
    app.cli.add_command(init_db_command)

    return app


# client/auth.py
# PWP_JournalAPI/client/auth.py
# client/auth.py

"""Client authentication utilities for the Journal API CLI."""
import os
import json
from typing import Optional
from client.config import TOKEN_FILE

def save_token(token: str) -> None:
    """Save JWT token to a file for authenticated requests.

    Args:
        token: The JWT token to save.
    """
    try:
        with open(TOKEN_FILE, "w", encoding="utf-8") as f:
            json.dump({"token": token}, f)
    except OSError as e:
        print(f"[red]Failed to save token: {e}[/red]")

def get_token() -> Optional[str]:
    """Retrieve the saved JWT token from file.

    Returns:
        The token string or None if not found.
    """
    if not os.path.exists(TOKEN_FILE):
        return None
    try:
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return json.load(f).get("token")
    except OSError as e:
        print(f"[red]Failed to read token: {e}[/red]")
        return None

def clear_token() -> None:
    """Delete the stored JWT token to log out the user."""
    if os.path.exists(TOKEN_FILE):
        try:
            os.remove(TOKEN_FILE)
        except OSError as e:
            print(f"[red]Failed to clear token: {e}[/red]")

def get_auth() -> dict:
    """Return the authorization header if token exists.

    Returns:
        dict: Authorization header with bearer token or empty dict.
    """
    token = get_token()
    if token:
        return {"Authorization": f"Bearer {token}"}
    return {}

# client/auth_cli.py
# PWP_JournalAPI/client/auth_cli.py
"""CLI commands for authentication in the Journal API."""
import typer
import requests
from rich.console import Console
from . import auth
from . import config

console = Console()
auth_app = typer.Typer(help="Authentication commands")

@auth_app.command("register")
def register(
    username: str = typer.Option(
        ..., "--username", "-u", help="Your desired username"
    ),
    email: str = typer.Option(..., "--email", "-e", help="Your email address"),
    password: str = typer.Option(
        ..., "--password", "-p", hide_input=True, help="Your password"
    )
) -> None:
    """Register a new user with username, email, and password."""
    res = requests.post(
        f"{config.API_URL}/users/register",
        json={
            "username": username,
            "email": email,
            "password": password
        },
        timeout=5
    )

    if res.status_code == 201:
        console.print("[green]‚úÖ Registered![/green]")
    else:
        try:
            err = res.json()
            if "errors" in err:
                console.print(f"[red]‚ùå Validation Error: {err['errors']}[/red]")
            elif "error" in err:
                console.print(f"[red]‚ùå {err['error']}[/red]")
            else:
                console.print(f"[red]‚ùå Unexpected response: {err}[/red]")
        except (requests.JSONDecodeError, ValueError):
            console.print(f"[red]‚ùå Server error: {res.text}[/red]")

@auth_app.command("login")
def login(
    email: str = typer.Option(..., "--email", "-e", help="Your email"),
    password: str = typer.Option(
        ..., "--password", "-p", hide_input=True, help="Your password"
    )
) -> None:
    """Log in and store the JWT token."""
    res = requests.post(
        f"{config.API_URL}/users/login",
        json={"email": email, "password": password},
        timeout=5
    )
    if res.ok:
        auth.save_token(res.json()["token"])
        console.print("[green]‚úÖ Logged in[/green]")
    else:
        try:
            err = res.json()
            console.print(f"[red]‚ùå Login failed: {err.get('error', err)}[/red]")
        except (requests.JSONDecodeError, ValueError):
            console.print(f"[red]‚ùå Server error: {res.text}[/red]")

@auth_app.command("logout")
def logout() -> None:
    """Remove saved token (logout)."""
    auth.clear_token()
    console.print("[yellow]üîì Logged out[/yellow]")

@auth_app.command("me")
def me() -> None:
    """Check if you're logged in."""
    token = auth.get_token()
    if token:
        console.print("[green]üîê Logged in[/green]")
    else:
        console.print("[red]üîì Not logged in[/red]")

# client/comments_cli.py
# PWP_JournalAPI/client/comments_cli.py
"""CLI commands for managing comments in the Journal API."""
import typer
import requests
from rich.console import Console
from client import auth
from client import config

console = Console()
comment_app = typer.Typer(help="Manage comments")

@comment_app.command("list")
def list_comments(entry_id: int) -> None:
    """List all comments for a journal entry.

    Args:
        entry_id: ID of the journal entry.
    """
    res = requests.get(
        f"{config.API_URL}/journal_entries/{entry_id}/comments",
        headers=auth.get_auth(),
        timeout=5
    )
    if res.status_code == 200:
        for c in res.json():
            console.print(f"[bold cyan][{c['id']}][/bold cyan] {c['content']}")
    else:
        console.print(f"[red]‚ùå Failed to list comments: {res.json()}[/red]")

@comment_app.command("add")
def add_comment(entry_id: int, content: str) -> None:
    """Add a comment to a journal entry.

    Args:
        entry_id: ID of the journal entry.
        content: Content of the comment.
    """
    res = requests.post(
        f"{config.API_URL}/journal_entries/{entry_id}/comments",
        json={"content": content},
        headers=auth.get_auth(),
        timeout=5
    )
    if res.ok:
        console.print("[green]‚úÖ Comment added[/green]")
    else:
        console.print(f"[red]‚ùå Failed to add comment: {res.json()}[/red]")

@comment_app.command("delete")
def delete_comment(entry_id: int, comment_id: int) -> None:
    """Delete a comment from a journal entry.

    Args:
        entry_id: ID of the journal entry.
        comment_id: ID of the comment to delete.
    """
    res = requests.delete(
        f"{config.API_URL}/journal_entries/{entry_id}/comments/{comment_id}",
        headers=auth.get_auth(),
        timeout=5
    )
    if res.ok:
        console.print("[green]‚úÖ Deleted[/green]")
    else:
        console.print(f"[red]‚ùå Failed to delete comment: {res.json()}[/red]")

# client/config.py
# PWP_JournalAPI/client/config.py
"""Configuration settings for the Journal API CLI."""
import os

API_URL = os.getenv("API_URL", "http://localhost:8000/api")
TOKEN_FILE = os.path.expanduser("~/.journal_token")

# client/entries_cli.py
# PWP_JournalAPI/client/entries_cli.py
"""CLI commands for managing journal entries in the Journal API."""
import typer
import requests
from rich.console import Console
from client import auth
from client import config

console = Console()
entry_app = typer.Typer(help="Manage journal entries")

@entry_app.command("list")
def list_entries() -> None:
    """List all your journal entries."""
    token = auth.get_token()
    if not token:
        console.print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    res = requests.get(
        f"{config.API_URL}/journal_entries",
        headers={"Authorization": f"Bearer {token}"},
        timeout=5
    )
    if res.status_code == 200:
        entries = res.json()
        if not entries:
            console.print("[yellow]‚ö†Ô∏è No journal entries found.[/yellow]")
        for entry in entries:
            console.print(
                f"[bold cyan][{entry['id']}][/bold cyan] {entry['title']} - "
                f"Tags: {entry['tags']}"
            )
            console.print(
                f"  [dim]Last updated: {entry.get('last_updated', 'N/A')}[/dim]"
            )
            console.print("  [dim]-- -- --[/dim]")
    else:
        console.print(f"[red]‚ùå Failed to list entries: {res.json()}[/red]")

@entry_app.command("create")
def create(
    title: str = typer.Argument(..., help="Title of the journal entry"),
    content: str = typer.Argument(..., help="Content of the journal entry"),
    tags: str = typer.Option("", "--tags", "-t", help="Comma-separated tags")
) -> None:
    """Create a new journal entry."""
    token = auth.get_token()
    if not token:
        console.print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    tag_list = [t.strip() for t in tags.split(",") if t.strip()]

    res = requests.post(
        f"{config.API_URL}/journal_entries",
        json={
            "title": title,
            "content": content,
            "tags": tag_list
        },
        headers={"Authorization": f"Bearer {token}"},
        timeout=5
    )

    if res.status_code == 201:
        console.print("[green]‚úÖ Entry created successfully![/green]")
    else:
        console.print(f"[red]‚ùå Failed to create entry: {res.json()}[/red]")

@entry_app.command("delete")
def delete(entry_id: int = typer.Argument(..., help="ID of the entry to delete")) -> None:
    """Delete a journal entry by ID."""
    token = auth.get_token()
    if not token:
        console.print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    res = requests.delete(
        f"{config.API_URL}/journal_entries/{entry_id}",
        headers={"Authorization": f"Bearer {token}"},
        timeout=5
    )
    if res.status_code == 200:
        console.print("[green]‚úÖ Entry deleted successfully.[/green]")
    elif res.status_code == 404:
        console.print("[yellow]‚ö†Ô∏è Entry not found.[/yellow]")
    else:
        console.print(f"[red]‚ùå Failed to delete entry: {res.json()}[/red]")

# client/entries_client_cli.py
# PWP_JournalAPI/client/entries_client_cli.py
"""CLI commands for managing journal entries in the Journal API."""
import typer
import requests
from rich.console import Console
from client import auth
from client import config

console = Console()
entries_app = typer.Typer(help="Journal Entries")

@entries_app.command("list")
def list_entries() -> None:
    """List all your journal entries."""
    auth_headers = auth.get_auth()
    if not auth_headers:
        console.print("[red]‚ùå Please login first.[/red]")
        raise typer.Exit()

    resp = requests.get(
        f"{config.API_URL}/journal_entries",
        headers=auth_headers,
        timeout=5
    )
    if resp.status_code == 200:
        entries = resp.json()
        for entry in entries:
            console.print(
                f"[bold cyan]{entry['title']}[/bold cyan] (ID: {entry['id']})"
            )
            console.print(
                f"  Tags: {entry['tags']} | Updated: {entry['last_updated']}"
            )
            console.print("  [dim]-- -- --[/dim]\n")
    else:
        console.print(f"[red]‚ùå Failed to fetch entries: {resp.json()}[/red]")

@entries_app.command("create")
def create_entry(
    title: str = typer.Option(...),
    content: str = typer.Option(...),
    tags: str = typer.Option("")
) -> None:
    """Create a new journal entry."""
    auth_headers = auth.get_auth()
    if not auth_headers:
        console.print("[red]‚ùå Please login first.[/red]")
        raise typer.Exit()

    tag_list = [t.strip() for t in tags.split(",") if t.strip()]

    resp = requests.post(
        f"{config.API_URL}/journal_entries",
        json={
            "title": title,
            "content": content,
            "tags": tag_list
        },
        headers=auth_headers,
        timeout=5
    )

    if resp.status_code == 201:
        console.print("[green]‚úÖ Entry created successfully![/green]")
    else:
        console.print(f"[red]‚ùå Failed to create entry: {resp.json()}[/red]")

# client/main.py
# PWP_JournalAPI/client/main.py
"""Main CLI application for the Journal API."""
import typer
from client.auth_cli import auth_app
from client.entries_cli import entry_app
from client.comments_cli import comment_app

app = typer.Typer(help="Journal API CLI")
app.add_typer(auth_app, name="auth")
app.add_typer(entry_app, name="entry")
app.add_typer(comment_app, name="comment")

if __name__ == "__main__":
    app()

# client/token_utlis.py
# PWP_JournalAPI/client/main.py
"""Token utilities for the Journal API CLI."""
import os
import json

TOKEN_FILE = os.path.expanduser("~/.journal_token")

def save_token(token: str) -> None:
    """Save JWT token to a file.

    Args:
        token: The JWT token to save.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        json.dump({"token": token}, f)

def load_token() -> Optional[str]:
    """Retrieve the saved JWT token from file.

    Returns:
        The token string or None if not found.
    """
    if not os.path.exists(TOKEN_FILE):
        return None
    with open(TOKEN_FILE, "r", encoding="utf-8") as f:
        return json.load(f).get("token")

def clear_token() -> None:
    """Delete the stored JWT token."""
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

# code_data.py
import os

def write_python_files_to_txt(root_directory=".", output_file="output.txt"):
    with open(output_file, "w", encoding="utf-8") as outfile:
        # Walk through the root directory and all subdirectories
        for dirpath, dirnames, filenames in os.walk(root_directory):
            for filename in filenames:
                if filename.endswith(".py"):
                    # Construct the full file path
                    file_path = os.path.join(dirpath, filename)
                    # Write the file path to the output file as a comment header
                    outfile.write(f"# {file_path}\n")
                    try:
                        # Read the file content
                        with open(file_path, "r", encoding="utf-8") as infile:
                            content = infile.read()
                        outfile.write(content)
                    except Exception as e:
                        # In case of any errors, write an error message
                        outfile.write(f"# Error reading {file_path}: {e}\n")
                    # Add a couple of newlines as a separator between files
                    outfile.write("\n\n")

if __name__ == "__main__":
    # Adjust the root directory if your repo is elsewhere
    write_python_files_to_txt(root_directory=".", output_file="output.txt")


# data.py
from pathlib import Path
import json

def extract_content_from_ipynb(file_path: Path) -> str:
    """
    Extracts and concatenates the content of a Jupyter Notebook (.ipynb) file.
    Both code cells and markdown cells are extracted, preserving the order.
    Each cell is annotated with a header indicating its type.
    """
    try:
        notebook = json.loads(file_path.read_text(encoding="utf-8"))
        cells = notebook.get("cells", [])
        content_lines = []
        for idx, cell in enumerate(cells, start=1):
            cell_type = cell.get("cell_type", "unknown")
            # Add a header for this cell
            if cell_type == "code":
                content_lines.append(f"### Cell {idx}: Code")
            elif cell_type == "markdown":
                content_lines.append(f"### Cell {idx}: Markdown")
            else:
                content_lines.append(f"### Cell {idx}: {cell_type}")
            # Join the source lines; they are typically stored as a list of lines.
            source = "".join(cell.get("source", []))
            content_lines.append(source)
            content_lines.append("\n")  # Extra newline after each cell
        return "\n".join(content_lines)
    except Exception as e:
        return f"# Error reading {file_path}: {e}"

def export_code_and_directory_list(root_directory=".", code_file="code.txt", list_file="directories.txt"):
    """
    Traverses the given root directory to find all files with a .py or .ipynb extension.
    Writes to two files:
      - directories.txt: A list of the file paths.
      - code.txt: Each file‚Äôs path (as header) followed by its content.
        For .ipynb files, both code and markdown cells are included.
    """
    root = Path(root_directory)
    # Collect both .py and .ipynb files
    files = list(root.rglob("*.py")) + list(root.rglob("*.ipynb"))
    # Optional: sort files for a consistent order
    files.sort(key=lambda p: p.as_posix())

    with open(code_file, "w", encoding="utf-8") as code_out, open(list_file, "w", encoding="utf-8") as list_out:
        for file_path in files:
            # Write the file path to the directories file
            list_out.write(f"{file_path}\n")
            
            # Write the file path header in the code file
            code_out.write(f"# {file_path}\n")
            
            # Process the file according to its extension
            if file_path.suffix == ".ipynb":
                content = extract_content_from_ipynb(file_path)
            else:
                try:
                    content = file_path.read_text(encoding="utf-8")
                except Exception as e:
                    content = f"# Error reading {file_path}: {e}"
            
            code_out.write(content)
            code_out.write("\n\n")  # Add separation for readability

if __name__ == "__main__":
    # Adjust 'root_directory' if your repository root is different.
    export_code_and_directory_list(root_directory=".", code_file="code.txt", list_file="directories.txt")


# docker_code.py
import os

# Create the docs directory if it doesn't exist
os.makedirs("docs", exist_ok=True)

# Define the Swagger 2.0 openapi.yaml content
openapi_yaml_content = """swagger: "2.0"
info:
  title: PWP Journal API
  description: API documentation for the journaling platform.
  version: "1.0"
host: localhost:8000
basePath: /
schemes:
  - http
consumes:
  - application/json
produces:
  - application/json
securityDefinitions:
  BearerAuth:
    type: apiKey
    name: Authorization
    in: header
    description: >
      JWT Authorization header using the Bearer scheme.
      Example: "Authorization: Bearer {token}"
paths:
  /users/register:
    post:
      summary: Register a new user
      tags:
        - Users
      parameters:
        - in: body
          name: user
          description: User registration data
          required: true
          schema:
            type: object
            properties:
              username:
                type: string
              email:
                type: string
              password:
                type: string
      responses:
        201:
          description: User created successfully
        400:
          description: Email or username already exists
        422:
          description: Validation error
  /users/login:
    post:
      summary: Login and retrieve a JWT token
      tags:
        - Users
      parameters:
        - in: body
          name: credentials
          description: User login data
          required: true
          schema:
            type: object
            properties:
              email:
                type: string
              password:
                type: string
      responses:
        200:
          description: JWT token returned
        401:
          description: Invalid credentials
  /entries/:
    get:
      summary: Get all journal entries for the current user
      tags:
        - Journal Entries
      security:
        - BearerAuth: []
      responses:
        200:
          description: A list of journal entries
    post:
      summary: Create a new journal entry
      tags:
        - Journal Entries
      security:
        - BearerAuth: []
      parameters:
        - in: body
          name: entry
          required: true
          schema:
            type: object
            properties:
              title:
                type: string
              content:
                type: string
              tags:
                type: array
                items:
                  type: string
      responses:
        201:
          description: Entry created
        422:
          description: Validation error
"""

# Write the content to docs/openapi.yaml
with open("docs/openapi.yaml", "w") as f:
    f.write(openapi_yaml_content)



# extensions.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()  # Create a single DB instance


# init_db.py
from app import create_app
from extensions import db

app = create_app()
with app.app_context():
    db.create_all()
print("Database initialized.")


# insert_from_files.py
import csv
from app import create_app
from extensions import db
from models import User, JournalEntry, EditHistory, Comment
from datetime import datetime
import json
from datetime import datetime, timezone
from werkzeug.security import generate_password_hash

app = create_app()

def list_to_json(lst):
    return json.dumps(lst)

def insert_users(file_path):
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            username, email, password = [field.strip() for field in row]
            if db.session.query(User).filter_by(email=email).first():
                print(f"‚ö†Ô∏è Skipping duplicate user: {email}")
                continue
            hashed_pw = generate_password_hash(password)
            user = User(username=username, email=email, password=hashed_pw)
            db.session.add(user)
        db.session.commit()
    print("‚úÖ Users added successfully!")


def insert_journal_entries(file_path):
    """Reads journal entries from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            user_id, title, content, tags, sentiment_score, sentiment_tag = row
            entry = JournalEntry(
                user_id=int(user_id),
                title=title.strip(),
                content=content.strip(),
                tags=list_to_json([tag.strip() for tag in tags.split(",")]),
                sentiment_score=float(sentiment_score),
                sentiment_tag=list_to_json([tag.strip() for tag in sentiment_tag.split(",")]),
                last_updated = datetime.now(timezone.utc)  # Correct way to get current UTC time: Depreciated# last_updated=datetime.utcnow()
            )
            db.session.add(entry)
        db.session.commit()
    print("‚úÖ Journal Entries added successfully!")

def insert_edit_history(file_path):
    """Reads edit history from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            journal_entry_id, user_id, previous_content, new_content = row
            edit = EditHistory(
                journal_entry_id=int(journal_entry_id),
                user_id=int(user_id),
                edited_at=datetime.now(timezone.utc), #datetime.utcnow(),
                previous_content=previous_content.strip(),
                new_content=new_content.strip()
            )
            db.session.add(edit)
        db.session.commit()
    print("‚úÖ Edit History added successfully!")

def insert_comments(file_path):
    """Reads comments from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            if len(row) < 3:
                print(f"‚ö†Ô∏è Skipping invalid row (not enough fields): {row}")
                continue

            journal_entry_id = int(row[0])
            user_id = int(row[1])
            content = ",".join(row[2:]).strip()  # Fix: Join all remaining parts as comment text

            comment = Comment(
                journal_entry_id=journal_entry_id,
                user_id=user_id,
                content=content,
                timestamp=datetime.utcnow()
            )
            db.session.add(comment)

        db.session.commit()
    print("‚úÖ Comments added successfully!")

if __name__ == "__main__":
    insert_users("data/users.txt")
    insert_journal_entries("data/journal_entries.txt")
    insert_edit_history("data/edit_history.txt")
    insert_comments("data/comments.txt")
    print("üéâ All data has been inserted successfully!")


# journalapi/__init__.py
"""Initialize the Flask application for the Journal API."""
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager
from journalapi.cli import init_db_command
from journalapi import api

db = SQLAlchemy()

def create_app(test_config=None):
    """Create and configure the Flask application.
    
    Args:
        test_config (dict, optional): Configuration for testing.
    
    Returns:
        Flask: The configured Flask application instance.
    """
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY="dev",
        SQLALCHEMY_DATABASE_URI="sqlite:///" + os.path.join(app.instance_path, "journal.db"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False
    )

    if test_config:
        app.config.update(test_config)
    else:
        app.config.from_pyfile("config.py", silent=True)

    try:
        os.makedirs(app.instance_path, exist_ok=True)
    except OSError:
        pass

    db.init_app(app)
    JWTManager(app)
    
    app.register_blueprint(api.api_bp, url_prefix="/api")
    app.cli.add_command(init_db_command)
    
    return app

# journalapi/api.py
"""API blueprint and resource definitions for the Journal API."""
from flask import Blueprint
from flask_restful import Api
from journalapi.resources.user import UserRegisterResource, UserLoginResource, UserResource
from journalapi.resources.journal_entry import JournalEntryListResource, JournalEntryResource
from journalapi.resources.comment import CommentCollectionResource, CommentItemResource
from journalapi.resources.edit_history import EditHistoryResource

api_bp = Blueprint("api", __name__)
api = Api(api_bp)

# User endpoints
api.add_resource(UserRegisterResource, "/users/register")
api.add_resource(UserLoginResource, "/users/login")
api.add_resource(UserResource, "/users/<int:user_id>")

# Journal entry endpoints
api.add_resource(JournalEntryListResource, "/journal_entries")
api.add_resource(JournalEntryResource, "/journal_entries/<int:entry_id>")

# Comment endpoints
api.add_resource(CommentCollectionResource, "/journal_entries/<int:entry_id>/comments")
api.add_resource(CommentItemResource, "/journal_entries/<int:entry_id>/comments/<int:comment_id>")

# Edit history endpoint
api.add_resource(EditHistoryResource, "/journal_entries/<int:entry_id>/history")

# # PWP_JournalAPI/journalapi/api.py
# from flask import Blueprint
# from flask_restful import Api

# # your resources
# from journalapi.resources.user import (
#     UserRegisterResource, UserLoginResource, UserResource
# )
# from journalapi.resources.journal_entry import (
#     JournalEntryListResource, JournalEntryResource
# )
# from journalapi.resources.comment import (
#     CommentCollectionResource, CommentItemResource
# )
# from journalapi.resources.edit_history import EditHistoryResource

# api_bp = Blueprint("api", __name__, url_prefix="")  # or "/api" if you want
# api = Api(api_bp)

# # User endpoints
# api.add_resource(UserRegisterResource, "/users/register")
# api.add_resource(UserLoginResource, "/users/login")
# api.add_resource(UserResource, "/users/<int:user_id>")

# # Journal endpoints
# api.add_resource(JournalEntryListResource, "/entries/")
# api.add_resource(JournalEntryResource, "/entries/<int:entry_id>")

# # Comment endpoints
# api.add_resource(CommentCollectionResource, "/entries/<int:entry_id>/comments")
# api.add_resource(CommentItemResource, "/entries/<int:entry_id>/comments/<int:comment_id>")

# # If you add edit history:
# # journalapi/api.py
# from flask import Blueprint
# from flask_restful import Api

# # your resources
# from journalapi.resources.user import (
#     UserRegisterResource, UserLoginResource, UserResource
# )
# from journalapi.resources.journal_entry import (
#     JournalEntryListResource, JournalEntryResource
# )
# from journalapi.resources.comment import (
#     CommentCollectionResource, CommentItemResource
# )
# # from journalapi.resources.edit_history import EditHistoryResource

# api_bp = Blueprint("api", __name__, url_prefix="")  # or "/api" if you want
# api = Api(api_bp)

# # User endpoints
# api.add_resource(UserRegisterResource, "/users/register")
# api.add_resource(UserLoginResource, "/users/login")
# api.add_resource(UserResource, "/users/<int:user_id>")

# # Journal endpoints
# api.add_resource(JournalEntryListResource, "/entries/")
# api.add_resource(JournalEntryResource, "/entries/<int:entry_id>")

# # Comment endpoints
# api.add_resource(CommentCollectionResource, "/entries/<int:entry_id>/comments")
# api.add_resource(CommentItemResource, "/entries/<int:entry_id>/comments/<int:comment_id>")

# # If you add edit history:
# api.add_resource(EditHistoryResource, "/entries/<int:entry_id>/history")


# journalapi/cli.py
# PWP_JournalAPI/journalapi/cli.py
"""Command-line interface commands for the Journal API."""
import click
from flask.cli import with_appcontext
from extensions import db

@click.command("init-db")
@with_appcontext
def init_db_command():
    """Initialize the database with required tables."""
    db.create_all()
    click.echo("Initialized the database.")


# journalapi/handlers/comment_handler.py
# journalapi/handlers/comment_handler.py
from journalapi import db
from journalapi.models import Comment

class CommentHandler:
    @staticmethod
    def add_comment(entry_id, user_id, content):
        comment = Comment(journal_entry_id=entry_id, user_id=user_id, content=content)
        db.session.add(comment)
        db.session.commit()
        db.session.refresh(comment)
        return comment.to_dict()

    @staticmethod
    def get_comments(entry_id):
        comments = Comment.query.filter_by(journal_entry_id=entry_id).all()
        return [comment.to_dict() for comment in comments]

    @staticmethod
    def update_comment(comment_id, user_id, content):
        comment = Comment.query.get(comment_id)
        if comment and comment.user_id == user_id:
            comment.content = content
            db.session.commit()
            db.session.refresh(comment)
            return comment.to_dict()
        return None

    @staticmethod
    def delete_comment(comment_id, user_id):
        comment = Comment.query.get(comment_id)
        if comment and comment.user_id == user_id:
            db.session.delete(comment)
            db.session.commit()
            return True
        return False


# journalapi/handlers/journal_entry_handler.py
from journalapi import db
from journalapi.models import JournalEntry
from datetime import datetime, timezone
import json

class JournalEntryHandler:
    @staticmethod
    def create_entry(user_id, title, content, tags=None):
        tags = tags or []
        sentiment_score = 0.75
        sentiment_tag = ["positive"]
        new_entry = JournalEntry(
            user_id=user_id,
            title=title,
            content=content,
            tags=json.dumps(tags),
            sentiment_score=sentiment_score,
            sentiment_tag=json.dumps(sentiment_tag),
            last_updated=datetime.now(timezone.utc)
        )
        db.session.add(new_entry)
        db.session.commit()
        return {"entry_id": new_entry.id}

    @staticmethod
    def get_entries(user_id):
        entries = JournalEntry.query.filter_by(user_id=user_id).all()
        return [entry.to_dict() for entry in entries]

    @staticmethod
    def get_entry(entry_id):
        entry = JournalEntry.query.get(entry_id)
        return entry.to_dict() if entry else None

    @staticmethod
    def update_entry(entry_id, title=None, content=None, tags=None):
        entry = JournalEntry.query.get(entry_id)
        if not entry:
            return None
        if title:
            entry.title = title
        if content:
            entry.content = content
        if tags is not None:
            entry.tags = json.dumps(tags)
        db.session.commit()
        return entry.to_dict()

    @staticmethod
    def delete_entry(entry_id):
        entry = JournalEntry.query.get(entry_id)
        if entry:
            db.session.delete(entry)
            db.session.commit()
            return True
        return False


# journalapi/handlers/user_handler.py
from journalapi import db
from journalapi.models import User
from werkzeug.security import generate_password_hash, check_password_hash

class UserHandler:

    @staticmethod
    def register_user(username, email, password):
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            return None  # User already exists

        hashed_password = generate_password_hash(password)
        new_user = User(username=username, email=email, password=hashed_password)
        db.session.add(new_user)
        db.session.commit()
        return new_user

    @staticmethod
    def login_user(email, password):
        user = User.query.filter_by(email=email).first()
        if user and check_password_hash(user.password, password):
            return user
        return None

    @staticmethod
    def get_user(user_id):
        return User.query.get(user_id)

    @staticmethod
    def update_user(user_id, username=None, email=None, password=None):
        user = User.query.get(user_id)
        if not user:
            return None

        if username:
            user.username = username
        if email:
            user.email = email
        if password:
            user.password = generate_password_hash(password)

        db.session.commit()
        return user

    @staticmethod
    def delete_user(user_id):
        user = User.query.get(user_id)
        if user:
            db.session.delete(user)
            db.session.commit()
            return True
        return False

# journalapi/models.py
"""Database models for the Journal API."""
from datetime import datetime
import json
from werkzeug.security import check_password_hash
from extensions import db

class User(db.Model):
    """Represents a user in the Journal API."""
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(128), nullable=False)
    entries = db.relationship("JournalEntry", backref="user", lazy=True)
    comments = db.relationship("Comment", backref="user", lazy=True)

    def __repr__(self):
        """Return a string representation of the User."""
        return f"<User {self.username}>"

    def to_dict(self):
        """Convert the User to a dictionary.
        
        Returns:
            dict: User data as a dictionary.
        """
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email
        }

    def check_password(self, password):
        """Check if the provided password matches the stored hash.
        
        Args:
            password (str): The password to verify.
        
        Returns:
            bool: True if the password matches, False otherwise."""
        return check_password_hash(self.password, password)

class JournalEntry(db.Model):
    """Represents a journal entry in the Journal API."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    tags = db.Column(db.Text, nullable=True)
    sentiment_score = db.Column(db.Float, nullable=True)
    sentiment_tag = db.Column(db.Text, nullable=True)
    last_updated = db.Column(db.DateTime, nullable=True)
    comments = db.relationship("Comment", backref="journal_entry", lazy=True)
    history = db.relationship("EditHistory", backref="journal_entry", lazy=True)

    def __repr__(self):
        """Return a string representation of the JournalEntry."""
        return f"<JournalEntry {self.id}>"

    def to_dict(self):
        """Convert the JournalEntry to a dictionary.
        
        Returns:
            dict: JournalEntry data as a dictionary.
        """
        return {
            "id": self.id,
            "user_id": self.user_id,
            "title": self.title,
            "content": self.content,
            "tags": json.loads(self.tags) if self.tags else [],
            "sentiment_score": self.sentiment_score,
            "sentiment_tag": json.loads(self.sentiment_tag) if self.sentiment_tag else [],
            "last_updated": self.last_updated.isoformat() if self.last_updated else None
        }

class Comment(db.Model):
    """Represents a comment on a journal entry."""
    id = db.Column(db.Integer, primary_key=True)
    journal_entry_id = db.Column(db.Integer, db.ForeignKey("journal_entry.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        """Return a string representation of the Comment."""
        return f"<Comment {self.id}>"

    def to_dict(self):
        """Convert the Comment to a dictionary.
        
        Returns:
            dict: Comment data as a dictionary.
        """
        return {
            "id": self.id,
            "journal_entry_id": self.journal_entry_id,
            "user_id": self.user_id,
            "content": self.content,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None
        }

class EditHistory(db.Model):
    """Tracks edit history for journal entries."""
    id = db.Column(db.Integer, primary_key=True)
    journal_entry_id = db.Column(db.Integer, db.ForeignKey("journal_entry.id"), nullable=False)
    old_content = db.Column(db.Text, nullable=False)
    edited_at = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        """Return a string representation of the EditHistory."""
        return f"<EditHistory {self.id}>"

    def to_dict(self):
        """Convert the EditHistory to a dictionary.
        
        Returns:
            dict: EditHistory data as a dictionary.
        """
        return {
            "id": self.id,
            "journal_entry_id": self.journal_entry_id,
            "old_content": self.old_content,
            "edited_at": self.edited_at.isoformat() if self.edited_at else None
        }

# journalapi/resources/comment.py
"""Comment API resources for the Journal API."""
from flask_restful import Resource
from flask import request
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from extensions import db
from journalapi.models import Comment
from journalapi.utils import json_response
from schemas import CommentSchema

comment_schema = CommentSchema()

class CommentCollectionResource(Resource):
    """Handle comment creation and listing for a journal entry."""
    @jwt_required()
    def get(self, entry_id):
        """Retrieve all comments for a journal entry.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with list of comments.
        """
        comments = Comment.query.filter_by(journal_entry_id=entry_id).all()
        data = []
        for c in comments:
            item = {
                "id": c.id,
                "journal_entry_id": c.journal_entry_id,
                "user_id": c.user_id,
                "content": c.content,
                "timestamp": c.timestamp.isoformat() if c.timestamp else None,
                "_links": {
                    "self": {"href": f"/entries/{entry_id}/comments/{c.id}"},
                    "edit": {"href": f"/entries/{entry_id}/comments/{c.id}"},
                    "delete": {"href": f"/entries/{entry_id}/comments/{c.id}"}
                }
            }
            data.append(item)
        return json_response(data, 200)

    @jwt_required()
    def post(self, entry_id):
        """Create a new comment for a journal entry.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with created comment data.
        """
        try:
            data = comment_schema.load(request.get_json())
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        user_id = int(get_jwt_identity())
        comment = Comment(journal_entry_id=entry_id, user_id=user_id, content=data["content"])
        db.session.add(comment)
        db.session.commit()
        return json_response({"comment_id": comment.id}, 201)

class CommentItemResource(Resource):
    """Handle individual comment operations."""
    @jwt_required()
    def put(self, entry_id, comment_id):
        """Update a comment by ID.
        
        Args:
            entry_id (int): The ID of the journal entry.
            comment_id (int): The ID of the comment.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        try:
            data = comment_schema.load(request.get_json())
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        user_id = int(get_jwt_identity())
        comment = db.session.get(Comment, comment_id)
        if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
            return json_response({"error": "Not found"}, 404)
        comment.content = data["content"]
        db.session.commit()
        return json_response({"message": "Comment fully replaced"}, 200)

    @jwt_required()
    def delete(self, entry_id, comment_id):
        """Delete a comment by ID.
        
        Args:
            entry_id (int): The ID of the journal entry.
            comment_id (int): The ID of the comment.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        user_id = int(get_jwt_identity())
        comment = db.session.get(Comment, comment_id)
        if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
            return json_response({"error": "Not found"}, 404)
        db.session.delete(comment)
        db.session.commit()
        return json_response({"message": "Comment deleted successfully"}, 200)

# # PWP_JournalAPI/journalapi/resources/comment.py
# # journalapi/resources/comment.py
# from flask_restful import Resource
# from flask import request
# from flask_jwt_extended import jwt_required, get_jwt_identity
# from marshmallow import ValidationError
# from extensions import db
# from journalapi.models import Comment
# from journalapi.utils import JsonResponse
# from schemas import CommentSchema

# comment_schema = CommentSchema()

# class CommentCollectionResource(Resource):
#     @jwt_required()
#     def get(self, entry_id):
#         comments = Comment.query.filter_by(journal_entry_id=entry_id).all()
#         data = []
#         for c in comments:
#             item = {
#                 "id": c.id,
#                 "journal_entry_id": c.journal_entry_id,
#                 "user_id": c.user_id,
#                 "content": c.content,
#                 "timestamp": c.timestamp.isoformat() if c.timestamp else None,
#                 "_links": {
#                     "self": {"href": f"/entries/{entry_id}/comments/{c.id}"},
#                     "edit": {"href": f"/entries/{entry_id}/comments/{c.id}"},
#                     "delete": {"href": f"/entries/{entry_id}/comments/{c.id}"}
#                 }
#             }
#             data.append(item)
#         return JsonResponse(data, 200)

#     @jwt_required()
#     def post(self, entry_id):
#         try:
#             data = comment_schema.load(request.get_json())
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         user_id = int(get_jwt_identity())
#         comment = Comment(journal_entry_id=entry_id, user_id=user_id, content=data["content"])
#         db.session.add(comment)
#         db.session.commit()
#         return JsonResponse({"comment_id": comment.id}, 201)

# class CommentItemResource(Resource):
#     @jwt_required()
#     def put(self, entry_id, comment_id):
#         try:
#             data = comment_schema.load(request.get_json())
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         user_id = int(get_jwt_identity())
#         comment = db.session.get(Comment, comment_id)
#         if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
#             return JsonResponse({"error": "Not found"}, 404)
#         comment.content = data["content"]
#         db.session.commit()
#         return JsonResponse({"message": "Comment fully replaced"}, 200)

#     @jwt_required()
#     def delete(self, entry_id, comment_id):
#         user_id = int(get_jwt_identity())
#         comment = db.session.get(Comment, comment_id)
#         if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
#             return JsonResponse({"error": "Not found"}, 404)
#         db.session.delete(comment)
#         db.session.commit()
#         return JsonResponse({"message": "Comment deleted successfully"}, 200)

# journalapi/resources/edit_history.py
"""Edit history API resources for the Journal API."""
from flask_restful import Resource
from flask_jwt_extended import jwt_required, get_jwt_identity
from journalapi.models import EditHistory
from journalapi.utils import json_response

class EditHistoryResource(Resource):
    """Handle edit history retrieval for a journal entry."""
    @jwt_required()
    def get(self, entry_id):
        """Retrieve edit history for a journal entry.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with list of edit history records.
        """
        edits = EditHistory.query.filter_by(journal_entry_id=entry_id).all()
        data = [edit.to_dict() for edit in edits]
        return json_response(data, 200)

# journalapi/resources/journal_entry.py
"""Journal entry API resources for the Journal API."""
from flask_restful import Resource
from flask import request
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
import json
from extensions import db
from journalapi.models import JournalEntry
from journalapi.utils import json_response
from schemas import JournalEntrySchema

entry_schema = JournalEntrySchema()

class JournalEntryListResource(Resource):
    """Handle journal entry creation and listing."""
    @jwt_required()
    def get(self):
        """Retrieve all journal entries for the authenticated user.
        
        Returns:
            tuple: JSON response with list of journal entries.
        """
        user_id = int(get_jwt_identity())
        entries = JournalEntry.query.filter_by(user_id=user_id).all()
        data = []
        for e in entries:
            item = {
                "id": e.id,
                "title": e.title,
                "tags": json.loads(e.tags),
                "last_updated": e.last_updated.isoformat() if e.last_updated else None
            }
            item["_links"] = {
                "self": {"href": f"/entries/{e.id}"},
                "edit": {"href": f"/entries/{e.id}"},
                "delete": {"href": f"/entries/{e.id}"},
                "comments": {"href": f"/entries/{e.id}/comments"},
                "history": {"href": f"/entries/{e.id}/history"}
            }
            data.append(item)
        return json_response(data, 200)

    @jwt_required()
    def post(self):
        """Create a new journal entry.
        
        Returns:
            tuple: JSON response with created entry ID.
        """
        user_id = int(get_jwt_identity())
        try:
            data = entry_schema.load(request.get_json())
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        new_entry = JournalEntry(
            user_id=user_id,
            title=data["title"],
            content=data["content"],
            tags=json.dumps(data.get("tags", [])),
            sentiment_score=0.75,
            sentiment_tag=json.dumps(["positive"])
        )
        db.session.add(new_entry)
        db.session.commit()
        return json_response({"entry_id": new_entry.id}, 201)

class JournalEntryResource(Resource):
    """Handle individual journal entry operations."""
    @jwt_required()
    def get(self, entry_id):
        """Retrieve a journal entry by ID.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with entry data or error message.
        """
        user_id = int(get_jwt_identity())
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return json_response({"error": "Not found"}, 404)
        entry_data = entry.to_dict()
        entry_data["_links"] = {
            "self": {"href": f"/entries/{entry_id}"},
            "edit": {"href": f"/entries/{entry_id}"},
            "delete": {"href": f"/entries/{entry_id}"},
            "comments": {"href": f"/entries/{entry_id}/comments"},
            "history": {"href": f"/entries/{entry_id}/history"}
        }
        return json_response(entry_data, 200)

    @jwt_required()
    def put(self, entry_id):
        """Update a journal entry by ID.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        user_id = int(get_jwt_identity())
        try:
            data = entry_schema.load(request.get_json())
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return json_response({"error": "Not found"}, 404)
        entry.title = data["title"]
        entry.content = data["content"]
        entry.tags = json.dumps(data["tags"])
        db.session.commit()
        return json_response({"message": "Entry fully replaced"}, 200)

    @jwt_required()
    def delete(self, entry_id):
        """Delete a journal entry by ID.
        
        Args:
            entry_id (int): The ID of the journal entry.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        user_id = int(get_jwt_identity())
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return json_response({"error": "Not found"}, 404)
        db.session.delete(entry)
        db.session.commit()
        return json_response({"message": "Entry deleted successfully"}, 200)

# # PWP_JournalAPI/journalapi/resources/journal_entry.py
# from flask_restful import Resource
# from flask import request
# from flask_jwt_extended import jwt_required, get_jwt_identity
# from marshmallow import ValidationError
# import json
# from extensions import db
# from journalapi.models import JournalEntry
# from journalapi.utils import JsonResponse
# from schemas import JournalEntrySchema

# entry_schema = JournalEntrySchema()

# class JournalEntryListResource(Resource):
#     @jwt_required()
#     def get(self):
#         user_id = int(get_jwt_identity())
#         entries = JournalEntry.query.filter_by(user_id=user_id).all()
#         data = []
#         for e in entries:
#             item = {
#                 "id": e.id,
#                 "title": e.title,
#                 "tags": json.loads(e.tags),
#                 "last_updated": e.last_updated.isoformat() if e.last_updated else None
#             }
#             item["_links"] = {
#                 "self": {"href": f"/entries/{e.id}"},
#                 "edit": {"href": f"/entries/{e.id}"},
#                 "delete": {"href": f"/entries/{e.id}"},
#                 "comments": {"href": f"/entries/{e.id}/comments"},
#                 "history": {"href": f"/entries/{e.id}/history"}
#             }
#             data.append(item)
#         return JsonResponse(data, 200)

#     @jwt_required()
#     def post(self):
#         user_id = int(get_jwt_identity())
#         try:
#             data = entry_schema.load(request.get_json())
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         new_entry = JournalEntry(
#             user_id=user_id,
#             title=data["title"],
#             content=data["content"],
#             tags=json.dumps(data.get("tags", [])),
#             sentiment_score=0.75,
#             sentiment_tag=json.dumps(["positive"])
#         )
#         db.session.add(new_entry)
#         db.session.commit()
#         return JsonResponse({"entry_id": new_entry.id}, 201)

# class JournalEntryResource(Resource):
#     @jwt_required()
#     def get(self, entry_id):
#         user_id = int(get_jwt_identity())
#         entry = db.session.get(JournalEntry, entry_id)
#         if not entry or entry.user_id != user_id:
#             return JsonResponse({"error": "Not found"}, 404)
#         entry_data = entry.to_dict()
#         entry_data["_links"] = {
#             "self": {"href": f"/entries/{entry_id}"},
#             "edit": {"href": f"/entries/{entry_id}"},
#             "delete": {"href": f"/entries/{entry_id}"},
#             "comments": {"href": f"/entries/{entry_id}/comments"},
#             "history": {"href": f"/entries/{entry_id}/history"}
#         }
#         return JsonResponse(entry_data, 200)

#     @jwt_required()
#     def put(self, entry_id):
#         user_id = int(get_jwt_identity())
#         try:
#             data = entry_schema.load(request.get_json())
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         entry = db.session.get(JournalEntry, entry_id)
#         if not entry or entry.user_id != user_id:
#             return JsonResponse({"error": "Not found"}, 404)
#         entry.title = data["title"]
#         entry.content = data["content"]
#         entry.tags = json.dumps(data["tags"])
#         db.session.commit()
#         return JsonResponse({"message": "Entry fully replaced"}, 200)

#     @jwt_required()
#     def delete(self, entry_id):
#         user_id = int(get_jwt_identity())
#         entry = db.session.get(JournalEntry, entry_id)
#         if not entry or entry.user_id != user_id:
#             return JsonResponse({"error": "Not found"}, 404)
#         db.session.delete(entry)
#         db.session.commit()
#         return JsonResponse({"message": "Entry deleted successfully"}, 200)


# journalapi/resources/user.py
"""User-related API resources for the Journal API."""
from flask_restful import Resource
from flask import request, current_app
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from werkzeug.security import generate_password_hash, check_password_hash
from marshmallow import ValidationError
import traceback
from extensions import db
from journalapi.models import User
from journalapi.utils import json_response
from schemas import UserRegisterSchema, UserLoginSchema

register_schema = UserRegisterSchema()
login_schema = UserLoginSchema()

class UserRegisterResource(Resource):
    """Handle user registration."""
    def post(self):
        """Register a new user.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        try:
            data = register_schema.load(request.get_json())
            if User.query.filter_by(email=data["email"]).first():
                return json_response({"error": "Email already registered"}, 400)
            if User.query.filter_by(username=data["username"]).first():
                return json_response({"error": "Username already taken"}, 400)
            hashed_password = generate_password_hash(data["password"])
            user = User(username=data["username"], email=data["email"], password=hashed_password)
            db.session.add(user)
            db.session.commit()
            return json_response({"message": "User registered successfully"}, 201)
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        except Exception as e:
            current_app.logger.error("‚ö†Ô∏è Registration failed: %s", e)
            current_app.logger.error(traceback.format_exc())
            return json_response({"error": "Internal server error"}, 500)

class UserLoginResource(Resource):
    """Handle user login."""
    def post(self):
        """Log in a user and return a JWT token.
        
        Returns:
            tuple: JSON response with token or error message.
        """
        try:
            data = login_schema.load(request.get_json())
        except ValidationError as err:
            return json_response({"errors": err.messages}, 422)
        user = User.query.filter_by(email=data["email"]).first()
        if not user or not check_password_hash(user.password, data["password"]):
            return json_response({"error": "Invalid credentials"}, 401)
        token = create_access_token(identity=str(user.id))
        return json_response({"token": token}, 200)

class UserResource(Resource):
    """Handle user data retrieval and modification."""
    @jwt_required()
    def get(self, user_id):
        """Retrieve a user's data by ID.
        
        Args:
            user_id (int): The ID of the user.
        
        Returns:
            tuple: JSON response with user data or error message.
        """
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return json_response({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return json_response({"error": "User not found"}, 404)
        return json_response({"id": user.id, "username": user.username, "email": user.email}, 200)

    @jwt_required()
    def put(self, user_id):
        """Update a user's data by ID.
        
        Args:
            user_id (int): The ID of the user.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return json_response({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return json_response({"error": "User not found"}, 404)
        data = request.get_json() or {}
        if "username" in data:
            user.username = data["username"]
        if "email" in data:
            user.email = data["email"]
        if "password" in data:
            user.password = generate_password_hash(data["password"])
        db.session.commit()
        return json_response({"message": "User updated successfully"}, 200)

    @jwt_required()
    def delete(self, user_id):
        """Delete a user by ID.
        
        Args:
            user_id (int): The ID of the user.
        
        Returns:
            tuple: JSON response with success message or error.
        """
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return json_response({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return json_response({"error": "User not found"}, 404)
        db.session.delete(user)
        db.session.commit()
        return json_response({"message": "User deleted successfully"}, 200)

# # PWP_JournalAPI/resources/user.py
# from flask_restful import Resource
# from flask import request, current_app
# from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
# from werkzeug.security import generate_password_hash, check_password_hash
# from marshmallow import ValidationError
# import traceback
# from extensions import db
# from journalapi.models import User
# from journalapi.utils import JsonResponse

# try:
#     from schemas import UserRegisterSchema, UserLoginSchema
# except ImportError:
#     from ...schemas import UserRegisterSchema, UserLoginSchema

# register_schema = UserRegisterSchema()
# login_schema = UserLoginSchema()

# class UserRegisterResource(Resource):
#     def post(self):
#         try:
#             data = register_schema.load(request.get_json())
#             if User.query.filter_by(email=data["email"]).first():
#                 return JsonResponse({"error": "Email already registered"}, 400)
#             if User.query.filter_by(username=data["username"]).first():
#                 return JsonResponse({"error": "Username already taken"}, 400)
#             hashed_password = generate_password_hash(data["password"])
#             user = User(username=data["username"], email=data["email"], password=hashed_password)
#             db.session.add(user)
#             db.session.commit()
#             return JsonResponse({"message": "User registered successfully"}, 201)
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         except Exception as e:
#             current_app.logger.error("‚ö†Ô∏è Registration failed: %s", e)
#             current_app.logger.error(traceback.format_exc())
#             return JsonResponse({"error": "Internal server error"}, 500)

# class UserLoginResource(Resource):
#     def post(self):
#         try:
#             data = login_schema.load(request.get_json())
#         except ValidationError as err:
#             return JsonResponse({"errors": err.messages}, 422)
#         user = User.query.filter_by(email=data["email"]).first()
#         if not user or not check_password_hash(user.password, data["password"]):
#             return JsonResponse({"error": "Invalid credentials"}, 401)
#         token = create_access_token(identity=str(user.id))
#         return JsonResponse({"token": token}, 200)

# class UserResource(Resource):
#     @jwt_required()
#     def get(self, user_id):
#         current_user_id = get_jwt_identity()
#         if str(user_id) != current_user_id:
#             return JsonResponse({"error": "Unauthorized"}, 403)
#         user = User.query.get(user_id)
#         if not user:
#             return JsonResponse({"error": "User not found"}, 404)
#         return JsonResponse({"id": user.id, "username": user.username, "email": user.email}, 200)

#     @jwt_required()
#     def put(self, user_id):
#         current_user_id = get_jwt_identity()
#         if str(user_id) != current_user_id:
#             return JsonResponse({"error": "Unauthorized"}, 403)
#         user = User.query.get(user_id)
#         if not user:
#             return JsonResponse({"error": "User not found"}, 404)
#         data = request.get_json() or {}
#         if "username" in data:
#             user.username = data["username"]
#         if "email" in data:
#             user.email = data["email"]
#         if "password" in data:
#             user.password = generate_password_hash(data["password"])
#         db.session.commit()
#         return JsonResponse({"message": "User updated successfully"}, 200)

#     @jwt_required()
#     def delete(self, user_id):
#         current_user_id = get_jwt_identity()
#         if str(user_id) != current_user_id:
#             return JsonResponse({"error": "Unauthorized"}, 403)
#         user = User.query.get(user_id)
#         if not user:
#             return JsonResponse({"error": "User not found"}, 404)
#         db.session.delete(user)
#         db.session.commit()
#         return JsonResponse({"message": "User deleted successfully"}, 200)


# journalapi/utils.py
# PWP_JournalAPI/journalapi/utils.py
"""Utility functions for the Journal API."""
import json
from datetime import datetime, timedelta
import jwt
from werkzeug.security import check_password_hash
from journalapi.models import User

def json_response(data, status_code=200):
    """Create a JSON response with the given data and status code.
    
    Args:
        data: The data to serialize as JSON.
        status_code (int): HTTP status code (default: 200).
    
    Returns:
        tuple: Flask response tuple (json, status, headers).
    """
    return json.dumps(data), status_code, {"Content-Type": "application/json"}

def authenticate_user(username, password):
    """Authenticate a user with the given credentials.
    
    Args:
        username (str): The user's username.
        password (str): The user's password.
    
    Returns:
        User: The authenticated user object, or None if authentication fails.
    """
    user = User.query.filter_by(username=username).first()
    if user and check_password_hash(user.password, password):
        return user
    return None

def generate_token(user):
    """Generate a JWT token for the given user.
    
    Args:
        user: The user object to generate a token for.
    
    Returns:
        str: The generated JWT token.
    """
    payload = {
        "user_id": user.id,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, "secret_key", algorithm="HS256")

# import json
# from flask import Response

# def JsonResponse(body, status=200, mimetype="application/json"):
#     if isinstance(body, dict) and "_links" not in body:
#         if "id" in body:
#             resource_type = detect_resource_type(body)
#             body["_links"] = generate_links(resource_type, body["id"])
#     return Response(json.dumps(body), status=status, mimetype=mimetype)

# def detect_resource_type(data):
#     if "title" in data:
#         return "entry"
#     elif "email" in data:
#         return "user"
#     elif "content" in data and "journal_entry_id" in data:
#         return "comment"
#     return None

# def generate_links(resource_type, id_):
#     if resource_type == "entry":
#         return {
#             "self": {"href": f"/entries/{id_}"},
#             "edit": {"href": f"/entries/{id_}"},
#             "delete": {"href": f"/entries/{id_}"},
#             "comments": {"href": f"/entries/{id_}/comments"},
#             "history": {"href": f"/entries/{id_}/history"}
#         }
#     elif resource_type == "user":
#         return {
#             "self": {"href": f"/users/{id_}"},
#             "edit": {"href": f"/users/{id_}"},
#             "delete": {"href": f"/users/{id_}"}
#         }
#     elif resource_type == "comment":
#         return {
#             "self": {"href": f"/entries/{id_}/comments/{id_}"},
#             "edit": {"href": f"/entries/{id_}/comments/{id_}"},
#             "delete": {"href": f"/entries/{id_}/comments/{id_}"}
#         }
#     return {}


# manage.py
#!/usr/bin/env python
# manage.py

from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run()  # Runs the Flask development server (not for production)


# schemas.py
"""Marshmallow schemas for the Journal API."""
from marshmallow import Schema, fields, validate

class CommentSchema(Schema):
    """Schema for validating comment data."""
    content = fields.Str(required=True, validate=validate.Length(min=1))

class JournalEntrySchema(Schema):
    """Schema for validating journal entry data."""
    title = fields.Str(required=True, validate=validate.Length(min=1, max=100))
    content = fields.Str(required=True, validate=validate.Length(min=1))
    tags = fields.List(fields.Str(), missing=[])

class UserRegisterSchema(Schema):
    """Schema for validating user registration data."""
    username = fields.Str(required=True, validate=validate.Length(min=3, max=80))
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=6), load_only=True)

class UserLoginSchema(Schema):
    """Schema for validating user login data."""
    email = fields.Email(required=True)
    password = fields.Str(required=True, load_only=True)

# # schemas.py
# from marshmallow import Schema, fields, validate, EXCLUDE

# class UserRegisterSchema(Schema):
#     class Meta:
#         unknown = EXCLUDE
#     username = fields.Str(required=True, validate=validate.Length(min=1))
#     email = fields.Email(required=True)
#     password = fields.Str(required=True, validate=validate.Length(min=6))

# class UserLoginSchema(Schema):
#     class Meta:
#         unknown = EXCLUDE
#     email = fields.Email(required=True)
#     password = fields.Str(required=True)

# class JournalEntrySchema(Schema):
#     class Meta:
#         unknown = EXCLUDE
#     title = fields.Str(required=True)
#     content = fields.Str(required=True)
#     tags = fields.List(fields.Str(), required=True)

# class CommentSchema(Schema):
#     class Meta:
#         unknown = EXCLUDE
#     content = fields.Str(required=True, validate=validate.Length(min=1))

# setup.py
# PWP_JournalAPI/schemas.py
from setuptools import setup, find_packages

setup(
    name="journalapi",
    version="0.1.0",
    description="A Flask RESTful journaling API.",
    author="Your Name",
    packages=find_packages(),
    include_package_data=True,
    zip_safe=False,
    install_requires=[
        "flask",
        "flask-restful",
        "flask-sqlalchemy",
        "flask-jwt-extended",
        "werkzeug"
    ],
    python_requires='>=3.7',
)

# tests/__init__.py
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager

db = SQLAlchemy()

def create_app(test_config=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY="dev",
        SQLALCHEMY_DATABASE_URI="sqlite://" + os.path.join(app.instance_path, "journal.db"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False
    )

    if test_config:
        app.config.update(test_config)
    else:
        app.config.from_pyfile("config.py", silent=True)

    try:
        os.makedirs(app.instance_path, exist_ok=True)
    except OSError:
        pass

    db.init_app(app)
    JWTManager(app)

    from . import api
    app.register_blueprint(api.api_bp)

    from .cli import init_db_command
    app.cli.add_command(init_db_command)

    return app

# tests/conftest.py
"""Pytest fixtures for the Journal API tests."""
import pytest
import os
import sys

# Add project root to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app
from extensions import db

@pytest.fixture
def app():
    """Create a Flask app for testing with an in-memory database."""
    app = create_app({
        "TESTING": True,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:",
        "JWT_SECRET_KEY": "test-secret-key"
    })
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    """Provide a test client for the Flask app."""
    return app.test_client()

# tests/test_cli_flow.py
"""Tests for the Journal API CLI flow."""
import os
import subprocess
import unittest
import re
import time
from client.config import TOKEN_FILE
from app import create_app
from extensions import db

class TestJournalCLIFlow(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """Set up a clean test environment."""
        app = create_app({"SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"})
        with app.app_context():
            db.create_all()

    def run_cli(self, command):
        """Run a CLI command and return stdout and stderr as strings."""
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            env=dict(os.environ, PYTHONPATH="."),
            text=True
        )
        return result.stdout, result.stderr

    def test_cli_end_to_end(self):
        """Test the full CLI workflow: register, login, create entry, comment, and list."""
        email = f"foo_{int(time.time())}@example.com"

        # 1. Register a new user
        out, err = self.run_cli(
            f'python client/main.py auth register --username foo --email {email} --password testpass123'
        )
        self.assertTrue("success" in out.lower() or "‚úÖ" in out or "registered" in out,
                        f"Registration failed: stdout: {out}, stderr: {err}")

        # 2. Login
        out, err = self.run_cli(
            f'python client/main.py auth login --email {email} --password testpass123'
        )
        self.assertTrue("logged in" in out.lower() or "‚úÖ" in out,
                        f"Login failed: stdout: {out}, stderr: {err}")
        self.assertTrue(os.path.exists(TOKEN_FILE), "Token file not found after login.")

        # 3. Create a journal entry
        out, err = self.run_cli(
            'python client/main.py entry create "First Post" "This is my first journal." --tags "test,cli"'
        )
        self.assertTrue("success" in out.lower() or "‚úÖ" in out,
                        f"Entry creation failed: stdout: {out}, stderr: {err}")

        # 4. List entries and extract entry ID
        out, err = self.run_cli("python client/main.py entry list")
        self.assertIn("First Post", out, f"Entry list output did not include entry title: {out}")
        lines = out.strip().splitlines()
        entry_line = next((line for line in lines if "First Post" in line), None)
        self.assertIsNotNone(entry_line, "No entry line found in output.")
        match = re.search(r"\[(\d+)\]", entry_line)
        self.assertIsNotNone(match, "Could not extract entry ID from line: " + entry_line)
        entry_id = match.group(1)

        # 5. Add a comment to the entry
        out, err = self.run_cli(f'python client/main.py comment add {entry_id} "hello!"')
        self.assertTrue("success" in out.lower() or "‚úÖ" in out,
                        f"Comment add failed: stdout: {out}, stderr: {err}")

        # 6. List comments and verify the comment exists
        out, err = self.run_cli(f"python client/main.py comment list {entry_id}")
        print("DEBUG: comment list stdout ‚Üí", repr(out))
        print("DEBUG: comment list stderr ‚Üí", repr(err))
        self.assertIn("hello!", out, f"Comment 'hello!' not found in output: {out}")

    @classmethod
    def tearDownClass(cls):
        """Clean up token file after tests."""
        if os.path.exists(TOKEN_FILE):
            os.remove(TOKEN_FILE)
        app = create_app({"SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"})
        with app.app_context():
            db.drop_all()

if __name__ == "__main__":
    unittest.main()

# tests/test_comments.py
"""Tests for comment-related API routes."""
import unittest
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token
from journalapi.models import User, Comment, JournalEntry

class TestCommentRoutes(unittest.TestCase):
    def setUp(self):
        """Set up test user, entry, and token."""
        self.client = self.client  # Provided by pytest fixture
        with self.app.app_context():
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()
            self.user_id = user.id
            self.token = create_access_token(identity=str(user.id))

            entry = JournalEntry(
                user_id=self.user_id,
                title="Test Entry",
                content="Some test content"
            )
            db.session.add(entry)
            db.session.commit()
            self.entry_id = entry.id

    def test_add_comment(self):
        """Test adding a comment to a journal entry."""
        response = self.client.post(
            f"/api/journal_entries/{self.entry_id}/comments",
            json={"content": "This is a test comment."},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_add_comment] response JSON:", response.get_json())
        print("DEBUG [test_add_comment] status code:", response.status_code)
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertIn("comment_id", data)

    def test_get_comments(self):
        """Test retrieving comments for a journal entry."""
        self.client.post(
            f"/api/journal_entries/{self.entry_id}/comments",
            json={"content": "This is a test comment."},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        response = self.client.get(
            f"/api/journal_entries/{self.entry_id}/comments",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_get_comments] response JSON:", response.get_json())
        print("DEBUG [test_get_comments] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertGreater(len(data), 0)
        self.assertIn("content", data[0])

    def test_update_comment(self):
        """Test updating a comment."""
        create_resp = self.client.post(
            f"/api/journal_entries/{self.entry_id}/comments",
            json={"content": "Original Comment"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        comment_id = create_resp.get_json()["comment_id"]
        update_resp = self.client.put(
            f"/api/journal_entries/{self.entry_id}/comments/{comment_id}",
            json={"content": "Updated Comment"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_update_comment] response JSON:", update_resp.get_json())
        print("DEBUG [test_update_comment] status code:", update_resp.status_code)
        self.assertEqual(update_resp.status_code, 200)
        self.assertIn("fully replaced", update_resp.get_json()["message"].lower())

    def test_delete_comment(self):
        """Test deleting a comment."""
        create_resp = self.client.post(
            f"/api/journal_entries/{self.entry_id}/comments",
            json={"content": "Comment to be deleted"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        comment_id = create_resp.get_json()["comment_id"]
        delete_resp = self.client.delete(
            f"/api/journal_entries/{self.entry_id}/comments/{comment_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_delete_comment] response JSON:", delete_resp.get_json())
        print("DEBUG [test_delete_comment] status code:", delete_resp.status_code)
        self.assertEqual(delete_resp.status_code, 200)
        self.assertIn("deleted", delete_resp.get_json()["message"].lower())
        get_resp = self.client.get(
            f"/api/journal_entries/{self.entry_id}/comments",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        data = get_resp.get_json()
        self.assertFalse(any(c["id"] == comment_id for c in data))

    def test_add_comment_invalid_input(self):
        """Test adding a comment with invalid input."""
        response = self.client.post(
            f"/api/journal_entries/{self.entry_id}/comments",
            json={"content": ""},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 422)
        data = response.get_json()
        self.assertIn("errors", data)

if __name__ == "__main__":
    unittest.main()

# tests/test_edit_history.py
"""Tests for edit history API routes."""
import unittest
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token
from journalapi.models import User, JournalEntry, EditHistory

class TestEditHistoryRoutes(unittest.TestCase):
    def setUp(self):
        """Set up test user, entry, and token."""
        self.client = self.client  # Provided by pytest fixture
        with self.app.app_context():
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()
            self.user_id = user.id
            self.token = create_access_token(identity=str(user.id))

            entry = JournalEntry(
                user_id=self.user_id,
                title="Test Entry",
                content="Some test content"
            )
            db.session.add(entry)
            db.session.commit()
            self.entry_id = entry.id

            edit = EditHistory(
                journal_entry_id=self.entry_id,
                old_content="Original content"
            )
            db.session.add(edit)
            db.session.commit()

    def test_get_edit_history(self):
        """Test retrieving edit history for a journal entry."""
        response = self.client.get(
            f"/api/journal_entries/{self.entry_id}/history",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertGreater(len(data), 0)
        self.assertIn("old_content", data[0])

if __name__ == "__main__":
    unittest.main()

# tests/test_journal_entry_routes.py
"""Tests for journal entry API routes."""
import unittest
import json
from journalapi.models import User
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token

class TestJournalEntryRoutes(unittest.TestCase):
    def setUp(self):
        """Set up test user and token."""
        self.client = self.client  # Provided by pytest fixture
        with self.app.app_context():
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()
            self.user_id = user.id
            self.token = create_access_token(identity=str(user.id))

    def test_create_entry(self):
        """Test creating a journal entry."""
        response = self.client.post(
            "/api/journal_entries",
            json={
                "title": "Test Entry",
                "content": "Testing journal entry creation",
                "tags": ["test", "journal"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertIn("entry_id", data)
        self.entry_id = data["entry_id"]

    def test_get_entries(self):
        """Test retrieving all journal entries."""
        self.client.post(
            "/api/journal_entries",
            json={
                "title": "Test Entry",
                "content": "Testing journal entry creation",
                "tags": ["test"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        response = self.client.get(
            "/api/journal_entries",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertGreater(len(data), 0)
        self.assertIn("title", data[0])

    def test_get_entry(self):
        """Test retrieving a single journal entry."""
        create_resp = self.client.post(
            "/api/journal_entries",
            json={
                "title": "Test Entry",
                "content": "Testing journal entry creation",
                "tags": ["test"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        entry_id = create_resp.get_json()["entry_id"]
        response = self.client.get(
            f"/api/journal_entries/{entry_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertEqual(data["title"], "Test Entry")

    def test_update_entry(self):
        """Test updating a journal entry."""
        create_resp = self.client.post(
            "/api/journal_entries",
            json={
                "title": "Test Entry",
                "content": "Testing journal entry creation",
                "tags": ["test"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        entry_id = create_resp.get_json()["entry_id"]
        response = self.client.put(
            f"/api/journal_entries/{entry_id}",
            json={
                "title": "Updated Entry",
                "content": "Updated content",
                "tags": ["updated"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 200)
        self.assertIn("fully replaced", response.get_json()["message"].lower())

    def test_delete_entry(self):
        """Test deleting a journal entry."""
        create_resp = self.client.post(
            "/api/journal_entries",
            json={
                "title": "Test Entry",
                "content": "Testing journal entry creation",
                "tags": ["test"]
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        entry_id = create_resp.get_json()["entry_id"]
        response = self.client.delete(
            f"/api/journal_entries/{entry_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 200)
        self.assertIn("deleted", response.get_json()["message"].lower())

    def test_create_entry_invalid_input(self):
        """Test creating a journal entry with invalid input."""
        response = self.client.post(
            "/api/journal_entries",
            json={
                "title": "",
                "content": "",
                "tags": []
            },
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(response.status_code, 422)
        data = response.get_json()
        self.assertIn("errors", data)

if __name__ == "__main__":
    unittest.main()

# tests/test_user_routes.py
"""Tests for user-related API routes."""
import unittest
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token
from journalapi.models import User

class TestUserRoutes(unittest.TestCase):
    def setUp(self):
        """Set up test user and token."""
        self.client = self.client  # Provided by pytest fixture
        with self.app.app_context():
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()
            self.user_id = user.id
            self.token = create_access_token(identity=str(user.id))

    def test_get_user(self):
        """Test retrieving user data."""
        response = self.client.get(
            f"/api/users/{self.user_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_get_user] response JSON:", response.get_json())
        print("DEBUG [test_get_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("username", data)

    def test_update_user(self):
        """Test updating user data."""
        response = self.client.put(
            f"/api/users/{self.user_id}",
            json={"username": "updateduser", "email": "updated@example.com", "password": "newpassword123"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_update_user] response JSON:", response.get_json())
        print("DEBUG [test_update_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("updated", data["message"].lower())

    def test_delete_user(self):
        """Test deleting a user."""
        response = self.client.delete(
            f"/api/users/{self.user_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_delete_user] response JSON:", response.get_json())
        print("DEBUG [test_delete_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("deleted successfully", data["message"].lower())

    def test_register_user(self):
        """Test registering a new user."""
        response = self.client.post(
            "/api/users/register",
            json={
                "username": "newuser",
                "email": "new@example.com",
                "password": "password123"
            }
        )
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertIn("registered", data["message"].lower())

    def test_login_user(self):
        """Test logging in a user."""
        response = self.client.post(
            "/api/users/login",
            json={
                "email": "test@example.com",
                "password": "password123"
            }
        )
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("token", data)

if __name__ == "__main__":
    unittest.main()

# tests/test_utils.py
"""Tests for utility functions."""
import unittest
from werkzeug.security import generate_password_hash
from journalapi.models import User
from journalapi.utils import authenticate_user, generate_token, json_response

class TestUtils(unittest.TestCase):
    def setUp(self):
        """Set up test user."""
        self.client = self.client  # Provided by pytest fixture
        with self.app.app_context():
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()
            self.user = user

    def test_json_response(self):
        """Test creating a JSON response."""
        data = {"test": "value"}
        response, status, headers = json_response(data, 200)
        self.assertEqual(status, 200)
        self.assertIn("application/json", headers["Content-Type"])
        self.assertEqual(json.loads(response), data)

    def test_authenticate_user(self):
        """Test authenticating a user."""
        with self.app.app_context():
            user = authenticate_user("testuser", "password123")
            self.assertEqual(user.id, self.user.id)
            user = authenticate_user("testuser", "wrongpass")
            self.assertIsNone(user)

    def test_generate_token(self):
        """Test generating a JWT token."""
        with self.app.app_context():
            token = generate_token(self.user)
            decoded = jwt.decode(token, "secret_key", algorithms=["HS256"])
            self.assertEqual(decoded["user_id"], self.user.id)

if __name__ == "__main__":
    unittest.main()

# wsgi.py
# wsgi.py
from app import create_app

app = create_app()

