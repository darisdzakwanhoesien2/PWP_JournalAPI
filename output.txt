# ./insert_from_files.py
import csv
from app import create_app
from extensions import db
from models import User, JournalEntry, EditHistory, Comment
from datetime import datetime
import json
from datetime import datetime, timezone
from werkzeug.security import generate_password_hash

app = create_app()

def list_to_json(lst):
    return json.dumps(lst)

def insert_users(file_path):
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            username, email, password = [field.strip() for field in row]
            if db.session.query(User).filter_by(email=email).first():
                print(f"‚ö†Ô∏è Skipping duplicate user: {email}")
                continue
            hashed_pw = generate_password_hash(password)
            user = User(username=username, email=email, password=hashed_pw)
            db.session.add(user)
        db.session.commit()
    print("‚úÖ Users added successfully!")


def insert_journal_entries(file_path):
    """Reads journal entries from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            user_id, title, content, tags, sentiment_score, sentiment_tag = row
            entry = JournalEntry(
                user_id=int(user_id),
                title=title.strip(),
                content=content.strip(),
                tags=list_to_json([tag.strip() for tag in tags.split(",")]),
                sentiment_score=float(sentiment_score),
                sentiment_tag=list_to_json([tag.strip() for tag in sentiment_tag.split(",")]),
                last_updated = datetime.now(timezone.utc)  # Correct way to get current UTC time: Depreciated# last_updated=datetime.utcnow()
            )
            db.session.add(entry)
        db.session.commit()
    print("‚úÖ Journal Entries added successfully!")

def insert_edit_history(file_path):
    """Reads edit history from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            journal_entry_id, user_id, previous_content, new_content = row
            edit = EditHistory(
                journal_entry_id=int(journal_entry_id),
                user_id=int(user_id),
                edited_at=datetime.now(timezone.utc), #datetime.utcnow(),
                previous_content=previous_content.strip(),
                new_content=new_content.strip()
            )
            db.session.add(edit)
        db.session.commit()
    print("‚úÖ Edit History added successfully!")

def insert_comments(file_path):
    """Reads comments from file and inserts them into the database."""
    with open(file_path, "r") as file, app.app_context():
        reader = csv.reader(file)
        for row in reader:
            if len(row) < 3:
                print(f"‚ö†Ô∏è Skipping invalid row (not enough fields): {row}")
                continue

            journal_entry_id = int(row[0])
            user_id = int(row[1])
            content = ",".join(row[2:]).strip()  # Fix: Join all remaining parts as comment text

            comment = Comment(
                journal_entry_id=journal_entry_id,
                user_id=user_id,
                content=content,
                timestamp=datetime.utcnow()
            )
            db.session.add(comment)

        db.session.commit()
    print("‚úÖ Comments added successfully!")

if __name__ == "__main__":
    insert_users("data/users.txt")
    insert_journal_entries("data/journal_entries.txt")
    insert_edit_history("data/edit_history.txt")
    insert_comments("data/comments.txt")
    print("üéâ All data has been inserted successfully!")


# ./code_data.py
import os

def write_python_files_to_txt(root_directory=".", output_file="output.txt"):
    with open(output_file, "w", encoding="utf-8") as outfile:
        # Walk through the root directory and all subdirectories
        for dirpath, dirnames, filenames in os.walk(root_directory):
            for filename in filenames:
                if filename.endswith(".py"):
                    # Construct the full file path
                    file_path = os.path.join(dirpath, filename)
                    # Write the file path to the output file as a comment header
                    outfile.write(f"# {file_path}\n")
                    try:
                        # Read the file content
                        with open(file_path, "r", encoding="utf-8") as infile:
                            content = infile.read()
                        outfile.write(content)
                    except Exception as e:
                        # In case of any errors, write an error message
                        outfile.write(f"# Error reading {file_path}: {e}\n")
                    # Add a couple of newlines as a separator between files
                    outfile.write("\n\n")

if __name__ == "__main__":
    # Adjust the root directory if your repo is elsewhere
    write_python_files_to_txt(root_directory=".", output_file="output.txt")


# ./extensions.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()  # Create a single DB instance


# ./docker_code.py
import os

# Create the docs directory if it doesn't exist
os.makedirs("docs", exist_ok=True)

# Define the Swagger 2.0 openapi.yaml content
openapi_yaml_content = """swagger: "2.0"
info:
  title: PWP Journal API
  description: API documentation for the journaling platform.
  version: "1.0"
host: localhost:8000
basePath: /
schemes:
  - http
consumes:
  - application/json
produces:
  - application/json
securityDefinitions:
  BearerAuth:
    type: apiKey
    name: Authorization
    in: header
    description: >
      JWT Authorization header using the Bearer scheme.
      Example: "Authorization: Bearer {token}"
paths:
  /users/register:
    post:
      summary: Register a new user
      tags:
        - Users
      parameters:
        - in: body
          name: user
          description: User registration data
          required: true
          schema:
            type: object
            properties:
              username:
                type: string
              email:
                type: string
              password:
                type: string
      responses:
        201:
          description: User created successfully
        400:
          description: Email or username already exists
        422:
          description: Validation error
  /users/login:
    post:
      summary: Login and retrieve a JWT token
      tags:
        - Users
      parameters:
        - in: body
          name: credentials
          description: User login data
          required: true
          schema:
            type: object
            properties:
              email:
                type: string
              password:
                type: string
      responses:
        200:
          description: JWT token returned
        401:
          description: Invalid credentials
  /entries/:
    get:
      summary: Get all journal entries for the current user
      tags:
        - Journal Entries
      security:
        - BearerAuth: []
      responses:
        200:
          description: A list of journal entries
    post:
      summary: Create a new journal entry
      tags:
        - Journal Entries
      security:
        - BearerAuth: []
      parameters:
        - in: body
          name: entry
          required: true
          schema:
            type: object
            properties:
              title:
                type: string
              content:
                type: string
              tags:
                type: array
                items:
                  type: string
      responses:
        201:
          description: Entry created
        422:
          description: Validation error
"""

# Write the content to docs/openapi.yaml
with open("docs/openapi.yaml", "w") as f:
    f.write(openapi_yaml_content)



# ./setup.py
# PWP_JournalAPI/schemas.py
from setuptools import setup, find_packages

setup(
    name="journalapi",
    version="0.1.0",
    description="A Flask RESTful journaling API.",
    author="Your Name",
    packages=find_packages(),
    include_package_data=True,
    zip_safe=False,
    install_requires=[
        "flask",
        "flask-restful",
        "flask-sqlalchemy",
        "flask-jwt-extended",
        "werkzeug"
    ],
    python_requires='>=3.7',
)

# ./schemas.py
# schemas.py
from marshmallow import Schema, fields, validate, EXCLUDE

class UserRegisterSchema(Schema):
    class Meta:
        unknown = EXCLUDE
    username = fields.Str(required=True, validate=validate.Length(min=1))
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=6))

class UserLoginSchema(Schema):
    class Meta:
        unknown = EXCLUDE
    email = fields.Email(required=True)
    password = fields.Str(required=True)

class JournalEntrySchema(Schema):
    class Meta:
        unknown = EXCLUDE
    title = fields.Str(required=True)
    content = fields.Str(required=True)
    tags = fields.List(fields.Str(), required=True)

class CommentSchema(Schema):
    class Meta:
        unknown = EXCLUDE
    content = fields.Str(required=True, validate=validate.Length(min=1))

# ./app.py
# PWP_JournalAPI/app.py
import os
from flask import Flask
from flask_jwt_extended import JWTManager
from flasgger import Swagger
from extensions import db
from journalapi.api import api_bp
from journalapi.cli import init_db_command

def create_app(test_config=None):
    app = Flask(__name__, instance_relative_config=True)

    app.config.from_mapping(
        DEBUG=True,
        SECRET_KEY="dev",
        SQLALCHEMY_DATABASE_URI="sqlite:///" + os.path.join(app.instance_path, "journal.db"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
        SWAGGER={"title": "PWP Journal API", "uiversion": 3}
    )

    if test_config:
        app.config.update(test_config)

    os.makedirs(app.instance_path, exist_ok=True)

    db.init_app(app)
    JWTManager(app)
    Swagger(app, template_file="docs/openapi.yaml")  # <- Load your YAML here

    app.register_blueprint(api_bp)
    app.cli.add_command(init_db_command)

    return app


# ./manage.py
#!/usr/bin/env python
# manage.py

from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run()  # Runs the Flask development server (not for production)


# ./wsgi.py
# wsgi.py
from app import create_app

app = create_app()

# ./init_db.py
from app import create_app
from extensions import db

app = create_app()
with app.app_context():
    db.create_all()
print("Database initialized.")


# ./tests/test_user_routes.py
# PWP_JournalAPI/tests/test_user_routes.py

import sys
import os
import unittest
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app
from extensions import db
from journalapi.models import User

class TestUserRoutes(unittest.TestCase):
    def setUp(self):
        self.app = create_app({
            "TESTING": True,
            "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"
        })
        self.client = self.app.test_client()

        with self.app.app_context():
            db.create_all()

            # Create test user
            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()

            self.user_id = user.id  # integer
            # create token as string
            self.token = create_access_token(identity=str(self.user_id))

    def tearDown(self):
        with self.app.app_context():
            db.drop_all()

    def test_get_user(self):
        # 200 if user matches token
        response = self.client.get(
            f"/users/{self.user_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_get_user] response JSON:", response.get_json())
        print("DEBUG [test_get_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("username", data)

    def test_update_user(self):
        # 200 if user matches token
        response = self.client.put(
            f"/users/{self.user_id}",
            json={"username": "updateduser", "email": "updated@example.com", "password": "newpassword123"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_update_user] response JSON:", response.get_json())
        print("DEBUG [test_update_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("updated", data["message"].lower())

    def test_delete_user(self):
        # 200 if user matches token
        response = self.client.delete(
            f"/users/{self.user_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_delete_user] response JSON:", response.get_json())
        print("DEBUG [test_delete_user] status code:", response.status_code)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertIn("deleted successfully", data["message"].lower())

if __name__ == "__main__":
    unittest.main()


# ./tests/conftest.py
# PWP_JournalAPI/tests/conftest.py
import pytest
import os
import sys

# Add project root to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app
from extensions import db

@pytest.fixture
def test_client():
    # Create a test app with in-memory DB
    app = create_app({
        "TESTING": True,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:",
    })
    with app.app_context():
        db.create_all()
        yield app.test_client()
        db.drop_all()


# ./tests/__init__.py
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager

db = SQLAlchemy()

def create_app(test_config=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY="dev",
        SQLALCHEMY_DATABASE_URI="sqlite://" + os.path.join(app.instance_path, "journal.db"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False
    )

    if test_config:
        app.config.update(test_config)
    else:
        app.config.from_pyfile("config.py", silent=True)

    try:
        os.makedirs(app.instance_path, exist_ok=True)
    except OSError:
        pass

    db.init_app(app)
    JWTManager(app)

    from . import api
    app.register_blueprint(api.api_bp)

    from .cli import init_db_command
    app.cli.add_command(init_db_command)

    return app

# ./tests/test_cli_flow.py
# tests/test_cli_flow.py
import os
import subprocess
import unittest
import re
import time
from client.config import TOKEN_FILE

class TestJournalCLIFlow(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Reset the database for a clean test environment.
        subprocess.run(["python", "init_db.py"], check=True)

    def run_cli(self, command):
        """
        Run a CLI command and return stdout and stderr as strings.
        """
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            env=dict(os.environ, PYTHONPATH="."),
        )
        return result.stdout.decode(), result.stderr.decode()

    def test_cli_end_to_end(self):
        # Use a dynamic email to avoid duplicate user conflicts.
        email = f"foo_{int(time.time())}@example.com"

        # 1. Register a new user
        out, err = self.run_cli(
            f'python client/main.py auth register --username foo --email {email} --password testpass123'
        )
        self.assertIn("‚úÖ", out or err, f"Registration failed: stdout: {out}, stderr: {err}")

        # 2. Login
        out, err = self.run_cli(
            f'python client/main.py auth login --email {email} --password testpass123'
        )
        self.assertIn("‚úÖ Logged in", out or err, f"Login failed: stdout: {out}, stderr: {err}")
        self.assertTrue(os.path.exists(TOKEN_FILE), "Token file not found after login.")

        # 3. Create a journal entry
        out, err = self.run_cli(
            'python client/main.py entry create "First Post" "This is my first journal." --tags "test,cli"'
        )
        self.assertIn("‚úÖ", out or err, f"Entry creation failed: stdout: {out}, stderr: {err}")

        # 4. List entries and extract entry ID
        out, err = self.run_cli("python client/main.py entry list")
        self.assertIn("First Post", out, f"Entry list output did not include entry title: {out}")
        lines = out.strip().splitlines()
        entry_line = next((line for line in lines if "First Post" in line), None)
        self.assertIsNotNone(entry_line, "No entry line found in output.")
        match = re.search(r"\[(\d+)\]", entry_line)
        self.assertIsNotNone(match, "Could not extract entry ID from line: " + entry_line)
        entry_id = match.group(1)

        # 5. Add a comment to the entry (using positional arguments)
        out, err = self.run_cli(f'python client/main.py comment add {entry_id} "hello!"')
        self.assertIn("‚úÖ", out or err, f"Comment add failed: stdout: {out}, stderr: {err}")

        # 6. List comments and verify the comment exists (using the positional parameter for entry_id)
        out, err = self.run_cli(f"python client/main.py comment list {entry_id}")
        print("DEBUG: comment list stdout ‚Üí", repr(out))
        print("DEBUG: comment list stderr ‚Üí", repr(err))
        self.assertIn("hello!", out, f"Comment 'hello!' not found in output: {out}")

    @classmethod
    def tearDownClass(cls):
        # Clean up token file after tests run.
        if os.path.exists(TOKEN_FILE):
            os.remove(TOKEN_FILE)

if __name__ == "__main__":
    unittest.main()


# ./tests/test_comments.py
# PWP_JournalAPI/tests/test_comments.py

import sys
import os
import unittest
from werkzeug.security import generate_password_hash
from flask_jwt_extended import create_access_token

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app
from extensions import db
from journalapi.models import User, Comment, JournalEntry

class TestCommentRoutes(unittest.TestCase):
    def setUp(self):
        """
        Creates a fresh in-memory DB, adds a test user & entry,
        and logs that user in with create_access_token(...).
        """
        self.app = create_app({
            "TESTING": True,
            "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"
        })
        self.client = self.app.test_client()

        with self.app.app_context():
            db.create_all()

            hashed_password = generate_password_hash("password123")
            user = User(username="testuser", email="test@example.com", password=hashed_password)
            db.session.add(user)
            db.session.commit()

            self.user_id = user.id
            # IMPORTANT: use str(...) for the identity
            self.token = create_access_token(identity=str(user.id))

            # Create a test journal entry
            entry = JournalEntry(
                user_id=self.user_id,
                title="Test Entry",
                content="Some test content"
            )
            db.session.add(entry)
            db.session.commit()
            self.entry_id = entry.id

    def tearDown(self):
        with self.app.app_context():
            db.drop_all()

    def test_add_comment(self):
        response = self.client.post(
            f"/entries/{self.entry_id}/comments",
            json={"content": "This is a test comment."},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_add_comment] response JSON:", response.get_json())
        print("DEBUG [test_add_comment] status code:", response.status_code)

        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertIn("comment_id", data)

    def test_get_comments(self):
        # create a comment
        create_resp = self.client.post(
            f"/entries/{self.entry_id}/comments",
            json={"content": "This is a test comment."},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(create_resp.status_code, 201)

        response = self.client.get(
            f"/entries/{self.entry_id}/comments",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_get_comments] response JSON:", response.get_json())
        print("DEBUG [test_get_comments] status code:", response.status_code)

        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertGreater(len(data), 0)
        self.assertIn("content", data[0])

    def test_update_comment(self):
        create_resp = self.client.post(
            f"/entries/{self.entry_id}/comments",
            json={"content": "Original Comment"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(create_resp.status_code, 201)
        comment_id = create_resp.get_json()["comment_id"]

        update_resp = self.client.put(
            f"/entries/{self.entry_id}/comments/{comment_id}",
            json={"content": "Updated Comment"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_update_comment] response JSON:", update_resp.get_json())
        print("DEBUG [test_update_comment] status code:", update_resp.status_code)

        self.assertEqual(update_resp.status_code, 200)
        self.assertIn("fully replaced", update_resp.get_json()["message"].lower())

    def test_delete_comment(self):
        create_resp = self.client.post(
            f"/entries/{self.entry_id}/comments",
            json={"content": "Comment to be deleted"},
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(create_resp.status_code, 201)
        comment_id = create_resp.get_json()["comment_id"]

        delete_resp = self.client.delete(
            f"/entries/{self.entry_id}/comments/{comment_id}",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        print("DEBUG [test_delete_comment] response JSON:", delete_resp.get_json())
        print("DEBUG [test_delete_comment] status code:", delete_resp.status_code)

        self.assertEqual(delete_resp.status_code, 200)
        self.assertIn("deleted", delete_resp.get_json()["message"].lower())

        # verify gone
        get_resp = self.client.get(
            f"/entries/{self.entry_id}/comments",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        self.assertEqual(get_resp.status_code, 200)
        data = get_resp.get_json()
        self.assertFalse(any(c["id"] == comment_id for c in data))

if __name__ == "__main__":
    unittest.main()



# ./tests/test_journal_entry_routes.py
# PWP_JournalAPI/tests/test_journal_entry_routes.py

import unittest
import json
from app import create_app
from extensions import db

class TestJournalEntryRoutes(unittest.TestCase):
    def setUp(self):
        self.app = create_app({
            "TESTING": True,
            "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"
        })
        self.client = self.app.test_client()
        with self.app.app_context():
            db.create_all()
            # Create and log in a user
            self.client.post("/users/register", json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "password123"
            })
            response = self.client.post("/users/login", json={
                "email": "test@example.com",
                "password": "password123"
            })
            data = json.loads(response.data)
            self.token = data["token"]

    def tearDown(self):
        with self.app.app_context():
            db.session.remove()
            db.drop_all()

    def test_create_entry(self):
        response = self.client.post("/entries/", json={
            "title": "Test Entry",
            "content": "Testing journal entry creation",
            "tags": ["test", "journal"]
        }, headers={"Authorization": f"Bearer {self.token}"})
        self.assertEqual(response.status_code, 201)
        data = json.loads(response.data)
        self.assertIn("entry_id", data)

if __name__ == "__main__":
    unittest.main()


# ./client/auth.py
# PWP_JournalAPI/client/auth.py
# client/auth.py

import os
import json
from client.config import TOKEN_FILE

def save_token(token: str):
    """
    Save JWT token to a file for future authenticated requests.
    """
    try:
        with open(TOKEN_FILE, "w") as f:
            json.dump({"token": token}, f)
    except Exception as e:
        print(f"[red]‚ùå Failed to save token: {e}[/red]")

def get_token() -> str:
    """
    Load the saved JWT token from file.
    Returns the token string or None if not found.
    """
    if not os.path.exists(TOKEN_FILE):
        return None
    try:
        with open(TOKEN_FILE, "r") as f:
            return json.load(f).get("token")
    except Exception as e:
        print(f"[red]‚ùå Failed to read token: {e}[/red]")
        return None

def clear_token():
    """
    Delete the stored JWT token to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        try:
            os.remove(TOKEN_FILE)
        except Exception as e:
            print(f"[red]‚ùå Failed to clear token: {e}[/red]")

def get_auth():
    """
    Return the authorization header if token exists.
    Used by CLI commands to attach bearer token.
    """
    token = get_token()
    if token:
        return {"Authorization": f"Bearer {token}"}
    return {}


# ./client/config.py
# PWP_JournalAPI/client/config.py
import os

API_URL = os.getenv("API_URL", "http://localhost:8000")
TOKEN_FILE = os.path.expanduser("~/.journal_token")

# ./client/token_utlis.py
# PWP_JournalAPI/client/main.py
import os
import json

TOKEN_FILE = os.path.expanduser("~/.journal_token")

def save_token(token: str):
    with open(TOKEN_FILE, "w") as f:
        json.dump({"token": token}, f)

def load_token() -> str:
    if not os.path.exists(TOKEN_FILE):
        return None
    with open(TOKEN_FILE, "r") as f:
        return json.load(f).get("token")

def clear_token():
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)


# ./client/comments_cli.py
# PWP_JournalAPI/client/comments_cli.py
import typer
import requests
from rich import print
import auth, config # from client 

comment_app = typer.Typer(help="Manage comments")

@comment_app.command("list")
def list_comments(entry_id: int):
    res = requests.get(f"{config.API_URL}/entries/{entry_id}/comments", headers={"Authorization": f"Bearer {auth.get_token()}"})
    for c in res.json():
        print(f"[{c['id']}] {c['content']}")

@comment_app.command("add")
def add_comment(entry_id: int, content: str):
    res = requests.post(f"{config.API_URL}/entries/{entry_id}/comments", json={"content": content}, headers={"Authorization": f"Bearer {auth.get_token()}"})
    print("[green]‚úÖ Comment added[/green]" if res.ok else f"[red]‚ùå {res.json()}[/red]")

@comment_app.command("delete")
def delete_comment(entry_id: int, comment_id: int):
    res = requests.delete(f"{config.API_URL}/entries/{entry_id}/comments/{comment_id}", headers={"Authorization": f"Bearer {auth.get_token()}"})
    print("[green]‚úÖ Deleted[/green]" if res.ok else f"[red]‚ùå {res.json()}[/red]")


# ./client/entries_cli.py
# PWP_JournalAPI/client/entries_cli.py
import typer
import requests
from rich import print
from client import auth, config

entry_app = typer.Typer(help="Manage journal entries")


@entry_app.command("list")
def list_entries():
    """
    List all your journal entries.
    """
    token = auth.get_token()
    if not token:
        print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    res = requests.get(f"{config.API_URL}/entries/", headers={"Authorization": f"Bearer {token}"})
    if res.status_code == 200:
        entries = res.json()
        if not entries:
            print("[yellow]‚ö†Ô∏è No journal entries found.[/yellow]")
        for entry in entries:
            print(f"[bold cyan][{entry['id']}][/bold cyan] {entry['title']} - Tags: {entry['tags']}")
            print(f"  [dim]Last updated: {entry.get('last_updated', 'N/A')}[/dim]")
            print("  [dim]-- -- --[/dim]")
    else:
        print(f"[red]‚ùå Failed to list entries: {res.json()}[/red]")


@entry_app.command("create")
def create(
    title: str = typer.Argument(..., help="Title of the journal entry"),
    content: str = typer.Argument(..., help="Content of the journal entry"),
    tags: str = typer.Option("", "--tags", "-t", help="Comma-separated tags")
):
    """
    Create a new journal entry.
    """
    token = auth.get_token()
    if not token:
        print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    tag_list = [t.strip() for t in tags.split(",") if t.strip()]

    res = requests.post(f"{config.API_URL}/entries/", json={
        "title": title,
        "content": content,
        "tags": tag_list
    }, headers={"Authorization": f"Bearer {token}"})

    if res.status_code == 201:
        print("[green]‚úÖ Entry created successfully![/green]")
    else:
        print(f"[red]‚ùå Failed to create entry: {res.json()}[/red]")


@entry_app.command("delete")
def delete(entry_id: int = typer.Argument(..., help="ID of the entry to delete")):
    """
    Delete a journal entry by ID.
    """
    token = auth.get_token()
    if not token:
        print("[red]‚ùå You must login first[/red]")
        raise typer.Exit()

    res = requests.delete(f"{config.API_URL}/entries/{entry_id}", headers={"Authorization": f"Bearer {token}"})
    if res.status_code == 200:
        print("[green]‚úÖ Entry deleted successfully.[/green]")
    elif res.status_code == 404:
        print("[yellow]‚ö†Ô∏è Entry not found.[/yellow]")
    else:
        print(f"[red]‚ùå Failed to delete entry: {res.json()}[/red]")

# ./client/entries_client_cli.py
# PWP_JournalAPI/client/entries_client_cli.py
import typer
import requests
from rich import print
from PWP_JournalAPI.client import token_utlis

entries_app = typer.Typer(help="Journal Entries")

API_URL = "http://localhost:8000"

@entries_app.command("list")
def list_entries():
    """List all your journal entries"""
    auth = token_utlis.get_auth()
    if not auth:
        print("[red]‚ùå Please login first.[/red]")
        raise typer.Exit()

    resp = requests.get(f"{API_URL}/entries/", headers=auth)
    if resp.status_code == 200:
        entries = resp.json()
        for entry in entries:
            print(f"[bold cyan]{entry['title']}[/bold cyan] (ID: {entry['id']})")
            print(f"  Tags: {entry['tags']} | Updated: {entry['last_updated']}")
            print("  [dim]-- -- --[/dim]\n")
    else:
        print(f"[red]‚ùå Failed to fetch entries: {resp.json()}[/red]")

@entries_app.command("create")
def create_entry(
    title: str = typer.Option(...),
    content: str = typer.Option(...),
    tags: str = typer.Option("")
):
    """Create a new journal entry"""
    auth = token_utlis.get_auth()
    if not auth:
        print("[red]‚ùå Please login first.[/red]")
        raise typer.Exit()

    tag_list = [t.strip() for t in tags.split(",") if t.strip()]

    resp = requests.post(f"{API_URL}/entries/", json={
        "title": title,
        "content": content,
        "tags": tag_list
    }, headers=auth)

    if resp.status_code == 201:
        print("[green]‚úÖ Entry created successfully![/green]")
    else:
        print(f"[red]‚ùå Failed to create entry: {resp.json()}[/red]")


# ./client/main.py
# PWP_JournalAPI/client/main.py
import typer 
from auth_cli import auth_app # client.
from entries_cli import entry_app # client.
from comments_cli import comment_app # client.

app = typer.Typer(help="Journal API CLI")
app.add_typer(auth_app, name="auth")
app.add_typer(entry_app, name="entry")
app.add_typer(comment_app, name="comment")

if __name__ == "__main__":
    app()


# ./client/auth_cli.py
# PWP_JournalAPI/client/auth_cli.py
import typer
import requests
from rich import print
import auth, config  # from client

auth_app = typer.Typer(help="Authentication commands")

@auth_app.command("register")
def register(
    username: str = typer.Option(..., "--username", "-u", help="Your desired username"),
    email: str = typer.Option(..., "--email", "-e", help="Your email address"),
    password: str = typer.Option(..., "--password", "-p", hide_input=True, help="Your password")
):
    """
    Register a new user with username, email, and password.
    Handles validation and server errors cleanly.
    """
    res = requests.post(f"{config.API_URL}/users/register", json={
        "username": username,
        "email": email,
        "password": password
    })

    if res.status_code == 201:
        print("[green]‚úÖ Registered![/green]")
    else:
        try:
            err = res.json()
            if "errors" in err:
                print(f"[red]‚ùå Validation Error: {err['errors']}[/red]")
            elif "error" in err:
                print(f"[red]‚ùå {err['error']}[/red]")
            else:
                print(f"[red]‚ùå Unexpected response: {err}[/red]")
        except Exception:
            print(f"[red]‚ùå Server error: {res.text}[/red]")


@auth_app.command("login")
def login(
    email: str = typer.Option(..., "--email", "-e", help="Your email"),
    password: str = typer.Option(..., "--password", "-p", hide_input=True, help="Your password")
):
    """
    Log in and store the JWT token.
    """
    res = requests.post(f"{config.API_URL}/users/login", json={"email": email, "password": password})
    if res.ok:
        auth.save_token(res.json()["token"])
        print("[green]‚úÖ Logged in[/green]")
    else:
        try:
            err = res.json()
            print(f"[red]‚ùå Login failed: {err.get('error', err)}[/red]")
        except Exception:
            print(f"[red]‚ùå Server error: {res.text}[/red]")


@auth_app.command("logout")
def logout():
    """
    Remove saved token (logout).
    """
    auth.clear_token()
    print("[yellow]üîì Logged out[/yellow]")


@auth_app.command("me")
def me():
    """
    Check if you're logged in.
    """
    token = auth.get_token()
    print("[green]üîê Logged in[/green]" if token else "[red]üîì Not logged in[/red]")


# ./journalapi/models.py
# PWP_JournalAPI/journalapi/models.py
# journalapi/models.py
from datetime import datetime
import json
from extensions import db

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)

    journal_entries = db.relationship("JournalEntry", backref="author", cascade="all, delete-orphan")
    comments = db.relationship("Comment", backref="author", cascade="all, delete-orphan")
    edit_histories = db.relationship("EditHistory", backref="editor", cascade="all, delete-orphan")

    def to_dict(self):
        return {"id": self.id, "username": self.username, "email": self.email}

class JournalEntry(db.Model):
    __tablename__ = "journal_entries"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    tags = db.Column(db.String, default="[]")
    sentiment_score = db.Column(db.Float)
    sentiment_tag = db.Column(db.String, default="[]")
    date = db.Column(db.DateTime, default=datetime.utcnow)
    last_updated = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    comments = db.relationship("Comment", backref="journal_entry", cascade="all, delete-orphan")
    edit_histories = db.relationship("EditHistory", backref="journal_entry", cascade="all, delete-orphan")

    def to_dict(self):
        return {
            "id": self.id,
            "title": self.title,
            "content": self.content,
            "tags": json.loads(self.tags),
            "sentiment_score": self.sentiment_score,
            "sentiment_tag": json.loads(self.sentiment_tag) if self.sentiment_tag else [],
            "date": self.date.isoformat() if self.date else None,
            "last_updated": self.last_updated.isoformat() if self.last_updated else None
        }

class Comment(db.Model):
    __tablename__ = "comments"
    id = db.Column(db.Integer, primary_key=True)
    journal_entry_id = db.Column(db.Integer, db.ForeignKey("journal_entries.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            "id": self.id,
            "journal_entry_id": self.journal_entry_id,
            "user_id": self.user_id,
            "content": self.content,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None
        }

class EditHistory(db.Model):
    __tablename__ = "edit_history"
    id = db.Column(db.Integer, primary_key=True)
    journal_entry_id = db.Column(db.Integer, db.ForeignKey("journal_entries.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    edited_at = db.Column(db.DateTime, default=datetime.utcnow)
    previous_content = db.Column(db.Text, nullable=False)
    new_content = db.Column(db.Text, nullable=False)

    def to_dict(self):
        return {
            "id": self.id,
            "journal_entry_id": self.journal_entry_id,
            "user_id": self.user_id,
            "edited_at": self.edited_at.isoformat() if self.edited_at else None,
            "previous_content": self.previous_content,
            "new_content": self.new_content
        }


# ./journalapi/__init__.py
# from flask import Flask
# from flask_sqlalchemy import SQLAlchemy
# from flask_jwt_extended import JWTManager
# import os

# db = SQLAlchemy()

# def create_app(test_config=None):
#     app = Flask(__name__, instance_relative_config=True)
    
#     # Default config (used for development)
#     app.config.from_mapping(
#         SECRET_KEY="dev",
#         SQLALCHEMY_DATABASE_URI="sqlite:///" + os.path.join(app.instance_path, "journal.db"),
#         SQLALCHEMY_TRACK_MODIFICATIONS=False
#     )

#     # If test config is provided, override default
#     if test_config:
#         app.config.update(test_config)
#     else:
#         app.config.from_pyfile("config.py", silent=True)

#     try:
#         os.makedirs(app.instance_path, exist_ok=True)
#     except OSError:
#         pass

#     db.init_app(app)
#     JWTManager(app)

#     from . import api
#     app.register_blueprint(api.api_bp)

#     from .cli import init_db_command
#     app.cli.add_command(init_db_command)

#     return app


# ./journalapi/api.py
# PWP_JournalAPI/journalapi/api.py
from flask import Blueprint
from flask_restful import Api

# your resources
from journalapi.resources.user import (
    UserRegisterResource, UserLoginResource, UserResource
)
from journalapi.resources.journal_entry import (
    JournalEntryListResource, JournalEntryResource
)
from journalapi.resources.comment import (
    CommentCollectionResource, CommentItemResource
)
from journalapi.resources.edit_history import EditHistoryResource

api_bp = Blueprint("api", __name__, url_prefix="")  # or "/api" if you want
api = Api(api_bp)

# User endpoints
api.add_resource(UserRegisterResource, "/users/register")
api.add_resource(UserLoginResource, "/users/login")
api.add_resource(UserResource, "/users/<int:user_id>")

# Journal endpoints
api.add_resource(JournalEntryListResource, "/entries/")
api.add_resource(JournalEntryResource, "/entries/<int:entry_id>")

# Comment endpoints
api.add_resource(CommentCollectionResource, "/entries/<int:entry_id>/comments")
api.add_resource(CommentItemResource, "/entries/<int:entry_id>/comments/<int:comment_id>")

# If you add edit history:
# journalapi/api.py
from flask import Blueprint
from flask_restful import Api

# your resources
from journalapi.resources.user import (
    UserRegisterResource, UserLoginResource, UserResource
)
from journalapi.resources.journal_entry import (
    JournalEntryListResource, JournalEntryResource
)
from journalapi.resources.comment import (
    CommentCollectionResource, CommentItemResource
)
# from journalapi.resources.edit_history import EditHistoryResource

api_bp = Blueprint("api", __name__, url_prefix="")  # or "/api" if you want
api = Api(api_bp)

# User endpoints
api.add_resource(UserRegisterResource, "/users/register")
api.add_resource(UserLoginResource, "/users/login")
api.add_resource(UserResource, "/users/<int:user_id>")

# Journal endpoints
api.add_resource(JournalEntryListResource, "/entries/")
api.add_resource(JournalEntryResource, "/entries/<int:entry_id>")

# Comment endpoints
api.add_resource(CommentCollectionResource, "/entries/<int:entry_id>/comments")
api.add_resource(CommentItemResource, "/entries/<int:entry_id>/comments/<int:comment_id>")

# If you add edit history:
api.add_resource(EditHistoryResource, "/entries/<int:entry_id>/history")


# ./journalapi/cli.py
# PWP_JournalAPI/journalapi/cli.py
import click
from flask.cli import with_appcontext
from extensions import db

@click.command("init-db")
@with_appcontext
def init_db_command():
    db.create_all()
    click.echo("Initialized the database.")


# ./journalapi/utils.py
# PWP_JournalAPI/journalapi/utils.py
import json
from flask import Response

def JsonResponse(body, status=200, mimetype="application/json"):
    if isinstance(body, dict) and "_links" not in body:
        if "id" in body:
            resource_type = detect_resource_type(body)
            body["_links"] = generate_links(resource_type, body["id"])
    return Response(json.dumps(body), status=status, mimetype=mimetype)

def detect_resource_type(data):
    if "title" in data:
        return "entry"
    elif "email" in data:
        return "user"
    elif "content" in data and "journal_entry_id" in data:
        return "comment"
    return None

def generate_links(resource_type, id_):
    if resource_type == "entry":
        return {
            "self": {"href": f"/entries/{id_}"},
            "edit": {"href": f"/entries/{id_}"},
            "delete": {"href": f"/entries/{id_}"},
            "comments": {"href": f"/entries/{id_}/comments"},
            "history": {"href": f"/entries/{id_}/history"}
        }
    elif resource_type == "user":
        return {
            "self": {"href": f"/users/{id_}"},
            "edit": {"href": f"/users/{id_}"},
            "delete": {"href": f"/users/{id_}"}
        }
    elif resource_type == "comment":
        return {
            "self": {"href": f"/entries/{id_}/comments/{id_}"},
            "edit": {"href": f"/entries/{id_}/comments/{id_}"},
            "delete": {"href": f"/entries/{id_}/comments/{id_}"}
        }
    return {}


# ./journalapi/resources/user.py
# PWP_JournalAPI/resources/user.py
from flask_restful import Resource
from flask import request, current_app
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from werkzeug.security import generate_password_hash, check_password_hash
from marshmallow import ValidationError
import traceback
from extensions import db
from journalapi.models import User
from journalapi.utils import JsonResponse

try:
    from schemas import UserRegisterSchema, UserLoginSchema
except ImportError:
    from ...schemas import UserRegisterSchema, UserLoginSchema

register_schema = UserRegisterSchema()
login_schema = UserLoginSchema()

class UserRegisterResource(Resource):
    def post(self):
        try:
            data = register_schema.load(request.get_json())
            if User.query.filter_by(email=data["email"]).first():
                return JsonResponse({"error": "Email already registered"}, 400)
            if User.query.filter_by(username=data["username"]).first():
                return JsonResponse({"error": "Username already taken"}, 400)
            hashed_password = generate_password_hash(data["password"])
            user = User(username=data["username"], email=data["email"], password=hashed_password)
            db.session.add(user)
            db.session.commit()
            return JsonResponse({"message": "User registered successfully"}, 201)
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        except Exception as e:
            current_app.logger.error("‚ö†Ô∏è Registration failed: %s", e)
            current_app.logger.error(traceback.format_exc())
            return JsonResponse({"error": "Internal server error"}, 500)

class UserLoginResource(Resource):
    def post(self):
        try:
            data = login_schema.load(request.get_json())
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        user = User.query.filter_by(email=data["email"]).first()
        if not user or not check_password_hash(user.password, data["password"]):
            return JsonResponse({"error": "Invalid credentials"}, 401)
        token = create_access_token(identity=str(user.id))
        return JsonResponse({"token": token}, 200)

class UserResource(Resource):
    @jwt_required()
    def get(self, user_id):
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return JsonResponse({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return JsonResponse({"error": "User not found"}, 404)
        return JsonResponse({"id": user.id, "username": user.username, "email": user.email}, 200)

    @jwt_required()
    def put(self, user_id):
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return JsonResponse({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return JsonResponse({"error": "User not found"}, 404)
        data = request.get_json() or {}
        if "username" in data:
            user.username = data["username"]
        if "email" in data:
            user.email = data["email"]
        if "password" in data:
            user.password = generate_password_hash(data["password"])
        db.session.commit()
        return JsonResponse({"message": "User updated successfully"}, 200)

    @jwt_required()
    def delete(self, user_id):
        current_user_id = get_jwt_identity()
        if str(user_id) != current_user_id:
            return JsonResponse({"error": "Unauthorized"}, 403)
        user = User.query.get(user_id)
        if not user:
            return JsonResponse({"error": "User not found"}, 404)
        db.session.delete(user)
        db.session.commit()
        return JsonResponse({"message": "User deleted successfully"}, 200)


# ./journalapi/resources/journal_entry.py
# PWP_JournalAPI/journalapi/resources/journal_entry.py
from flask_restful import Resource
from flask import request
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
import json
from extensions import db
from journalapi.models import JournalEntry
from journalapi.utils import JsonResponse
from schemas import JournalEntrySchema

entry_schema = JournalEntrySchema()

class JournalEntryListResource(Resource):
    @jwt_required()
    def get(self):
        user_id = int(get_jwt_identity())
        entries = JournalEntry.query.filter_by(user_id=user_id).all()
        data = []
        for e in entries:
            item = {
                "id": e.id,
                "title": e.title,
                "tags": json.loads(e.tags),
                "last_updated": e.last_updated.isoformat() if e.last_updated else None
            }
            item["_links"] = {
                "self": {"href": f"/entries/{e.id}"},
                "edit": {"href": f"/entries/{e.id}"},
                "delete": {"href": f"/entries/{e.id}"},
                "comments": {"href": f"/entries/{e.id}/comments"},
                "history": {"href": f"/entries/{e.id}/history"}
            }
            data.append(item)
        return JsonResponse(data, 200)

    @jwt_required()
    def post(self):
        user_id = int(get_jwt_identity())
        try:
            data = entry_schema.load(request.get_json())
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        new_entry = JournalEntry(
            user_id=user_id,
            title=data["title"],
            content=data["content"],
            tags=json.dumps(data.get("tags", [])),
            sentiment_score=0.75,
            sentiment_tag=json.dumps(["positive"])
        )
        db.session.add(new_entry)
        db.session.commit()
        return JsonResponse({"entry_id": new_entry.id}, 201)

class JournalEntryResource(Resource):
    @jwt_required()
    def get(self, entry_id):
        user_id = int(get_jwt_identity())
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return JsonResponse({"error": "Not found"}, 404)
        entry_data = entry.to_dict()
        entry_data["_links"] = {
            "self": {"href": f"/entries/{entry_id}"},
            "edit": {"href": f"/entries/{entry_id}"},
            "delete": {"href": f"/entries/{entry_id}"},
            "comments": {"href": f"/entries/{entry_id}/comments"},
            "history": {"href": f"/entries/{entry_id}/history"}
        }
        return JsonResponse(entry_data, 200)

    @jwt_required()
    def put(self, entry_id):
        user_id = int(get_jwt_identity())
        try:
            data = entry_schema.load(request.get_json())
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return JsonResponse({"error": "Not found"}, 404)
        entry.title = data["title"]
        entry.content = data["content"]
        entry.tags = json.dumps(data["tags"])
        db.session.commit()
        return JsonResponse({"message": "Entry fully replaced"}, 200)

    @jwt_required()
    def delete(self, entry_id):
        user_id = int(get_jwt_identity())
        entry = db.session.get(JournalEntry, entry_id)
        if not entry or entry.user_id != user_id:
            return JsonResponse({"error": "Not found"}, 404)
        db.session.delete(entry)
        db.session.commit()
        return JsonResponse({"message": "Entry deleted successfully"}, 200)


# ./journalapi/resources/comment.py
# PWP_JournalAPI/journalapi/resources/comment.py
# journalapi/resources/comment.py
from flask_restful import Resource
from flask import request
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from extensions import db
from journalapi.models import Comment
from journalapi.utils import JsonResponse
from schemas import CommentSchema

comment_schema = CommentSchema()

class CommentCollectionResource(Resource):
    @jwt_required()
    def get(self, entry_id):
        comments = Comment.query.filter_by(journal_entry_id=entry_id).all()
        data = []
        for c in comments:
            item = {
                "id": c.id,
                "journal_entry_id": c.journal_entry_id,
                "user_id": c.user_id,
                "content": c.content,
                "timestamp": c.timestamp.isoformat() if c.timestamp else None,
                "_links": {
                    "self": {"href": f"/entries/{entry_id}/comments/{c.id}"},
                    "edit": {"href": f"/entries/{entry_id}/comments/{c.id}"},
                    "delete": {"href": f"/entries/{entry_id}/comments/{c.id}"}
                }
            }
            data.append(item)
        return JsonResponse(data, 200)

    @jwt_required()
    def post(self, entry_id):
        try:
            data = comment_schema.load(request.get_json())
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        user_id = int(get_jwt_identity())
        comment = Comment(journal_entry_id=entry_id, user_id=user_id, content=data["content"])
        db.session.add(comment)
        db.session.commit()
        return JsonResponse({"comment_id": comment.id}, 201)

class CommentItemResource(Resource):
    @jwt_required()
    def put(self, entry_id, comment_id):
        try:
            data = comment_schema.load(request.get_json())
        except ValidationError as err:
            return JsonResponse({"errors": err.messages}, 422)
        user_id = int(get_jwt_identity())
        comment = db.session.get(Comment, comment_id)
        if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
            return JsonResponse({"error": "Not found"}, 404)
        comment.content = data["content"]
        db.session.commit()
        return JsonResponse({"message": "Comment fully replaced"}, 200)

    @jwt_required()
    def delete(self, entry_id, comment_id):
        user_id = int(get_jwt_identity())
        comment = db.session.get(Comment, comment_id)
        if not comment or comment.user_id != user_id or comment.journal_entry_id != entry_id:
            return JsonResponse({"error": "Not found"}, 404)
        db.session.delete(comment)
        db.session.commit()
        return JsonResponse({"message": "Comment deleted successfully"}, 200)

# ./journalapi/resources/edit_history.py
# PWP_JournalAPI/journalapi/resources/edit_history.py
from flask_restful import Resource
from flask_jwt_extended import jwt_required, get_jwt_identity
from journalapi.models import EditHistory
from journalapi.utils import JsonResponse

class EditHistoryResource(Resource):
    @jwt_required()
    def get(self, entry_id):
        edits = EditHistory.query.filter_by(journal_entry_id=entry_id).all()
        data = [edit.to_dict() for edit in edits]
        return JsonResponse(data, 200)


# ./journalapi/handlers/comment_handler.py
# journalapi/handlers/comment_handler.py
from journalapi import db
from journalapi.models import Comment

class CommentHandler:
    @staticmethod
    def add_comment(entry_id, user_id, content):
        comment = Comment(journal_entry_id=entry_id, user_id=user_id, content=content)
        db.session.add(comment)
        db.session.commit()
        db.session.refresh(comment)
        return comment.to_dict()

    @staticmethod
    def get_comments(entry_id):
        comments = Comment.query.filter_by(journal_entry_id=entry_id).all()
        return [comment.to_dict() for comment in comments]

    @staticmethod
    def update_comment(comment_id, user_id, content):
        comment = Comment.query.get(comment_id)
        if comment and comment.user_id == user_id:
            comment.content = content
            db.session.commit()
            db.session.refresh(comment)
            return comment.to_dict()
        return None

    @staticmethod
    def delete_comment(comment_id, user_id):
        comment = Comment.query.get(comment_id)
        if comment and comment.user_id == user_id:
            db.session.delete(comment)
            db.session.commit()
            return True
        return False


# ./journalapi/handlers/user_handler.py
from journalapi import db
from journalapi.models import User
from werkzeug.security import generate_password_hash, check_password_hash

class UserHandler:

    @staticmethod
    def register_user(username, email, password):
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            return None  # User already exists

        hashed_password = generate_password_hash(password)
        new_user = User(username=username, email=email, password=hashed_password)
        db.session.add(new_user)
        db.session.commit()
        return new_user

    @staticmethod
    def login_user(email, password):
        user = User.query.filter_by(email=email).first()
        if user and check_password_hash(user.password, password):
            return user
        return None

    @staticmethod
    def get_user(user_id):
        return User.query.get(user_id)

    @staticmethod
    def update_user(user_id, username=None, email=None, password=None):
        user = User.query.get(user_id)
        if not user:
            return None

        if username:
            user.username = username
        if email:
            user.email = email
        if password:
            user.password = generate_password_hash(password)

        db.session.commit()
        return user

    @staticmethod
    def delete_user(user_id):
        user = User.query.get(user_id)
        if user:
            db.session.delete(user)
            db.session.commit()
            return True
        return False

# ./journalapi/handlers/journal_entry_handler.py
from journalapi import db
from journalapi.models import JournalEntry
from datetime import datetime, timezone
import json

class JournalEntryHandler:
    @staticmethod
    def create_entry(user_id, title, content, tags=None):
        tags = tags or []
        sentiment_score = 0.75
        sentiment_tag = ["positive"]
        new_entry = JournalEntry(
            user_id=user_id,
            title=title,
            content=content,
            tags=json.dumps(tags),
            sentiment_score=sentiment_score,
            sentiment_tag=json.dumps(sentiment_tag),
            last_updated=datetime.now(timezone.utc)
        )
        db.session.add(new_entry)
        db.session.commit()
        return {"entry_id": new_entry.id}

    @staticmethod
    def get_entries(user_id):
        entries = JournalEntry.query.filter_by(user_id=user_id).all()
        return [entry.to_dict() for entry in entries]

    @staticmethod
    def get_entry(entry_id):
        entry = JournalEntry.query.get(entry_id)
        return entry.to_dict() if entry else None

    @staticmethod
    def update_entry(entry_id, title=None, content=None, tags=None):
        entry = JournalEntry.query.get(entry_id)
        if not entry:
            return None
        if title:
            entry.title = title
        if content:
            entry.content = content
        if tags is not None:
            entry.tags = json.dumps(tags)
        db.session.commit()
        return entry.to_dict()

    @staticmethod
    def delete_entry(entry_id):
        entry = JournalEntry.query.get(entry_id)
        if entry:
            db.session.delete(entry)
            db.session.commit()
            return True
        return False


